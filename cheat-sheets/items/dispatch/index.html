<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Swift Notes</title>
<meta name=keywords content><meta name=description content="Dispatch (Swift)
1. What is it?
Dispatch is the mechanism that decides which implementation a call will execute (and when that decision is made: compile-time vs runtime). In Swift, dispatch choices directly affect polymorphism, correctness (especially with protocol extensions), and performance.
2. What problem does it solve?

Enables polymorphism (same call, different behavior) via inheritance or protocols.
Balances flexibility vs performance (dynamic lookup vs direct calls).
Defines how overrides, protocol conformances, and runtime features (KVO/swizzling) work.

3. Types / Categories

  
      
          Kind
          Trigger / Where it appears
          Mechanism
          Typical cost
          Notes
      
  
  
      
          Static dispatch (direct call)
          struct/enum, final methods/classes, static functions, many generics
          Compiler emits a direct call
          Lowest
          Most optimizable (inline, specialize)
      
      
          Virtual dispatch (vtable)
          class inheritance + overridable methods
          vtable lookup
          Low–medium
          Enables override polymorphism
      
      
          Protocol dispatch (witness table)
          Calling protocol requirements through a protocol type
          witness table lookup
          Low–medium
          Key for any Protocol calls
      
      
          Obj-C message dispatch
          @objc dynamic, KVC/KVO, swizzling, selectors
          objc_msgSend
          Medium–high
          Most dynamic, least optimizable
      
  

4. How does it work in Swift?
Quick decision tree

Value types (struct/enum) → usually static dispatch
final class or final func → static dispatch (cannot be overridden)
Non-final class methods (especially overridden) → vtable dispatch
Protocol requirement calls via any Protocol → witness table dispatch
Protocol extension methods → static dispatch (common footgun)
Generic T: Protocol → often specialized by the compiler → can become close to static dispatch
@objc dynamic → Objective-C runtime dispatch (objc_msgSend)

Why protocol extensions can surprise you

A method implemented in a protocol extension is not always dispatched through the witness table.
If you call it via an existential (let x: any P = ...), Swift may bind to the extension implementation (static) instead of the conforming type’s method (dynamic through witness table).

Rule of thumb:"><meta name=author content><link rel=canonical href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/dispatch/><link crossorigin=anonymous href=https://sametkoyuncu.github.io/swift-notes/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://sametkoyuncu.github.io/swift-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sametkoyuncu.github.io/swift-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sametkoyuncu.github.io/swift-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://sametkoyuncu.github.io/swift-notes/apple-touch-icon.png><link rel=mask-icon href=https://sametkoyuncu.github.io/swift-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/dispatch/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/dispatch/"><meta property="og:site_name" content="Swift Notes"><meta property="og:title" content="Swift Notes"><meta property="og:description" content="Dispatch (Swift) 1. What is it? Dispatch is the mechanism that decides which implementation a call will execute (and when that decision is made: compile-time vs runtime). In Swift, dispatch choices directly affect polymorphism, correctness (especially with protocol extensions), and performance.
2. What problem does it solve? Enables polymorphism (same call, different behavior) via inheritance or protocols. Balances flexibility vs performance (dynamic lookup vs direct calls). Defines how overrides, protocol conformances, and runtime features (KVO/swizzling) work. 3. Types / Categories Kind Trigger / Where it appears Mechanism Typical cost Notes Static dispatch (direct call) struct/enum, final methods/classes, static functions, many generics Compiler emits a direct call Lowest Most optimizable (inline, specialize) Virtual dispatch (vtable) class inheritance + overridable methods vtable lookup Low–medium Enables override polymorphism Protocol dispatch (witness table) Calling protocol requirements through a protocol type witness table lookup Low–medium Key for any Protocol calls Obj-C message dispatch @objc dynamic, KVC/KVO, swizzling, selectors objc_msgSend Medium–high Most dynamic, least optimizable 4. How does it work in Swift? Quick decision tree Value types (struct/enum) → usually static dispatch final class or final func → static dispatch (cannot be overridden) Non-final class methods (especially overridden) → vtable dispatch Protocol requirement calls via any Protocol → witness table dispatch Protocol extension methods → static dispatch (common footgun) Generic T: Protocol → often specialized by the compiler → can become close to static dispatch @objc dynamic → Objective-C runtime dispatch (objc_msgSend) Why protocol extensions can surprise you A method implemented in a protocol extension is not always dispatched through the witness table. If you call it via an existential (let x: any P = ...), Swift may bind to the extension implementation (static) instead of the conforming type’s method (dynamic through witness table). Rule of thumb:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="cheat-sheets"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Dispatch (Swift)
1. What is it?
Dispatch is the mechanism that decides which implementation a call will execute (and when that decision is made: compile-time vs runtime). In Swift, dispatch choices directly affect polymorphism, correctness (especially with protocol extensions), and performance.
2. What problem does it solve?

Enables polymorphism (same call, different behavior) via inheritance or protocols.
Balances flexibility vs performance (dynamic lookup vs direct calls).
Defines how overrides, protocol conformances, and runtime features (KVO/swizzling) work.

3. Types / Categories

  
      
          Kind
          Trigger / Where it appears
          Mechanism
          Typical cost
          Notes
      
  
  
      
          Static dispatch (direct call)
          struct/enum, final methods/classes, static functions, many generics
          Compiler emits a direct call
          Lowest
          Most optimizable (inline, specialize)
      
      
          Virtual dispatch (vtable)
          class inheritance + overridable methods
          vtable lookup
          Low–medium
          Enables override polymorphism
      
      
          Protocol dispatch (witness table)
          Calling protocol requirements through a protocol type
          witness table lookup
          Low–medium
          Key for any Protocol calls
      
      
          Obj-C message dispatch
          @objc dynamic, KVC/KVO, swizzling, selectors
          objc_msgSend
          Medium–high
          Most dynamic, least optimizable
      
  

4. How does it work in Swift?
Quick decision tree

Value types (struct/enum) → usually static dispatch
final class or final func → static dispatch (cannot be overridden)
Non-final class methods (especially overridden) → vtable dispatch
Protocol requirement calls via any Protocol → witness table dispatch
Protocol extension methods → static dispatch (common footgun)
Generic T: Protocol → often specialized by the compiler → can become close to static dispatch
@objc dynamic → Objective-C runtime dispatch (objc_msgSend)

Why protocol extensions can surprise you

A method implemented in a protocol extension is not always dispatched through the witness table.
If you call it via an existential (let x: any P = ...), Swift may bind to the extension implementation (static) instead of the conforming type’s method (dynamic through witness table).

Rule of thumb:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Cheat Sheets","item":"https://sametkoyuncu.github.io/swift-notes/cheat-sheets/"},{"@type":"ListItem","position":2,"name":"","item":"https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/dispatch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Dispatch (Swift) 1. What is it? Dispatch is the mechanism that decides which implementation a call will execute (and when that decision is made: compile-time vs runtime). In Swift, dispatch choices directly affect polymorphism, correctness (especially with protocol extensions), and performance.\n2. What problem does it solve? Enables polymorphism (same call, different behavior) via inheritance or protocols. Balances flexibility vs performance (dynamic lookup vs direct calls). Defines how overrides, protocol conformances, and runtime features (KVO/swizzling) work. 3. Types / Categories Kind Trigger / Where it appears Mechanism Typical cost Notes Static dispatch (direct call) struct/enum, final methods/classes, static functions, many generics Compiler emits a direct call Lowest Most optimizable (inline, specialize) Virtual dispatch (vtable) class inheritance + overridable methods vtable lookup Low–medium Enables override polymorphism Protocol dispatch (witness table) Calling protocol requirements through a protocol type witness table lookup Low–medium Key for any Protocol calls Obj-C message dispatch @objc dynamic, KVC/KVO, swizzling, selectors objc_msgSend Medium–high Most dynamic, least optimizable 4. How does it work in Swift? Quick decision tree Value types (struct/enum) → usually static dispatch final class or final func → static dispatch (cannot be overridden) Non-final class methods (especially overridden) → vtable dispatch Protocol requirement calls via any Protocol → witness table dispatch Protocol extension methods → static dispatch (common footgun) Generic T: Protocol → often specialized by the compiler → can become close to static dispatch @objc dynamic → Objective-C runtime dispatch (objc_msgSend) Why protocol extensions can surprise you A method implemented in a protocol extension is not always dispatched through the witness table. If you call it via an existential (let x: any P = ...), Swift may bind to the extension implementation (static) instead of the conforming type’s method (dynamic through witness table). Rule of thumb:\n","keywords":[],"articleBody":"Dispatch (Swift) 1. What is it? Dispatch is the mechanism that decides which implementation a call will execute (and when that decision is made: compile-time vs runtime). In Swift, dispatch choices directly affect polymorphism, correctness (especially with protocol extensions), and performance.\n2. What problem does it solve? Enables polymorphism (same call, different behavior) via inheritance or protocols. Balances flexibility vs performance (dynamic lookup vs direct calls). Defines how overrides, protocol conformances, and runtime features (KVO/swizzling) work. 3. Types / Categories Kind Trigger / Where it appears Mechanism Typical cost Notes Static dispatch (direct call) struct/enum, final methods/classes, static functions, many generics Compiler emits a direct call Lowest Most optimizable (inline, specialize) Virtual dispatch (vtable) class inheritance + overridable methods vtable lookup Low–medium Enables override polymorphism Protocol dispatch (witness table) Calling protocol requirements through a protocol type witness table lookup Low–medium Key for any Protocol calls Obj-C message dispatch @objc dynamic, KVC/KVO, swizzling, selectors objc_msgSend Medium–high Most dynamic, least optimizable 4. How does it work in Swift? Quick decision tree Value types (struct/enum) → usually static dispatch final class or final func → static dispatch (cannot be overridden) Non-final class methods (especially overridden) → vtable dispatch Protocol requirement calls via any Protocol → witness table dispatch Protocol extension methods → static dispatch (common footgun) Generic T: Protocol → often specialized by the compiler → can become close to static dispatch @objc dynamic → Objective-C runtime dispatch (objc_msgSend) Why protocol extensions can surprise you A method implemented in a protocol extension is not always dispatched through the witness table. If you call it via an existential (let x: any P = ...), Swift may bind to the extension implementation (static) instead of the conforming type’s method (dynamic through witness table). Rule of thumb:\nIf you want dynamic behavior through any P, make it a protocol requirement and implement it in the conforming type. Treat protocol extensions as shared helpers, not as “overridable defaults”. some vs any (performance intuition) any P (existential): runtime container + witness table lookup. some P (opaque): compiler knows the concrete type (per function boundary) → more optimization opportunities (specialization / inlining), often closer to static dispatch. 5. Dangerous corners / Footguns ⚠️ Protocol extension “override” illusion: methods in extensions are not truly overridable the way class methods are. ⚠️ Existentials hide concrete types: any P can introduce runtime costs and can change which implementation gets called. ⚠️ Overusing non-final classes can prevent optimizations (no devirtualization / inlining). ⚠️ @objc dynamic makes behavior swizzlable but reduces compile-time guarantees and performance. 6. When should I use which? Prefer static dispatch by default: Use struct/enum for pure data + value semantics. Mark classes/methods final unless you truly need inheritance. Use vtable dispatch when: You need runtime polymorphism via inheritance (override-based design). Use protocol dispatch when: You need abstraction and testability (DI), especially across module boundaries. Prefer generics/some P when you want abstraction + performance. Use any P when you need heterogenous collections, dynamic storage, or API surface that must hide types. Use Obj-C dispatch when: Interop with Objective-C runtime is required (KVO, swizzling, selectors, some UIKit patterns). 7. 30-second summary If the compiler knows the exact target → direct (static) call. Classes with overrides → vtable. Protocol requirements via any Protocol → witness table. Protocol extension methods → often static (watch out). some Protocol helps performance because the compiler can specialize/in-line. @objc dynamic uses Obj-C runtime dispatch: most flexible, least optimizable. ","wordCount":"570","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/dispatch/"},"publisher":{"@type":"Organization","name":"Swift Notes","logo":{"@type":"ImageObject","url":"https://sametkoyuncu.github.io/swift-notes/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://sametkoyuncu.github.io/swift-notes/ accesskey=h title="Swift Notes (Alt + H)">Swift Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sametkoyuncu.github.io/swift-notes/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/ title="Cheat Sheets"><span>Cheat Sheets</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sametkoyuncu.github.io/swift-notes/>Home</a>&nbsp;»&nbsp;<a href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/>Cheat Sheets</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta><span>3 min</span></div></header><div class=post-content><h1 id=dispatch-swift>Dispatch (Swift)<a hidden class=anchor aria-hidden=true href=#dispatch-swift>#</a></h1><h2 id=1-what-is-it>1. What is it?<a hidden class=anchor aria-hidden=true href=#1-what-is-it>#</a></h2><p>Dispatch is the mechanism that decides <strong>which implementation</strong> a call will execute (and <strong>when</strong> that decision is made: compile-time vs runtime). In Swift, dispatch choices directly affect polymorphism, correctness (especially with protocol extensions), and performance.</p><h2 id=2-what-problem-does-it-solve>2. What problem does it solve?<a hidden class=anchor aria-hidden=true href=#2-what-problem-does-it-solve>#</a></h2><ul><li>Enables polymorphism (same call, different behavior) via inheritance or protocols.</li><li>Balances flexibility vs performance (dynamic lookup vs direct calls).</li><li>Defines how overrides, protocol conformances, and runtime features (KVO/swizzling) work.</li></ul><h2 id=3-types--categories>3. Types / Categories<a hidden class=anchor aria-hidden=true href=#3-types--categories>#</a></h2><table><thead><tr><th>Kind</th><th>Trigger / Where it appears</th><th>Mechanism</th><th>Typical cost</th><th>Notes</th></tr></thead><tbody><tr><td>Static dispatch (direct call)</td><td><code>struct</code>/<code>enum</code>, <code>final</code> methods/classes, <code>static</code> functions, many generics</td><td>Compiler emits a direct call</td><td>Lowest</td><td>Most optimizable (inline, specialize)</td></tr><tr><td>Virtual dispatch (vtable)</td><td><code>class</code> inheritance + overridable methods</td><td>vtable lookup</td><td>Low–medium</td><td>Enables <code>override</code> polymorphism</td></tr><tr><td>Protocol dispatch (witness table)</td><td>Calling protocol <strong>requirements</strong> through a protocol type</td><td>witness table lookup</td><td>Low–medium</td><td>Key for <code>any Protocol</code> calls</td></tr><tr><td>Obj-C message dispatch</td><td><code>@objc dynamic</code>, KVC/KVO, swizzling, selectors</td><td><code>objc_msgSend</code></td><td>Medium–high</td><td>Most dynamic, least optimizable</td></tr></tbody></table><h2 id=4-how-does-it-work-in-swift>4. How does it work in Swift?<a hidden class=anchor aria-hidden=true href=#4-how-does-it-work-in-swift>#</a></h2><h3 id=quick-decision-tree>Quick decision tree<a hidden class=anchor aria-hidden=true href=#quick-decision-tree>#</a></h3><ul><li><strong>Value types (<code>struct</code>/<code>enum</code>)</strong> → usually <strong>static dispatch</strong></li><li><strong><code>final class</code> or <code>final func</code></strong> → <strong>static dispatch</strong> (cannot be overridden)</li><li><strong>Non-final <code>class</code> methods</strong> (especially overridden) → <strong>vtable</strong> dispatch</li><li><strong>Protocol requirement calls via <code>any Protocol</code></strong> → <strong>witness table</strong> dispatch</li><li><strong>Protocol extension methods</strong> → <strong>static dispatch</strong> (common footgun)</li><li><strong>Generic <code>T: Protocol</code></strong> → often <strong>specialized</strong> by the compiler → can become close to <strong>static dispatch</strong></li><li><strong><code>@objc dynamic</code></strong> → <strong>Objective-C runtime</strong> dispatch (<code>objc_msgSend</code>)</li></ul><h3 id=why-protocol-extensions-can-surprise-you>Why protocol extensions can surprise you<a hidden class=anchor aria-hidden=true href=#why-protocol-extensions-can-surprise-you>#</a></h3><ul><li>A method implemented in a <strong>protocol extension</strong> is not always dispatched through the witness table.</li><li>If you call it via an <strong>existential</strong> (<code>let x: any P = ...</code>), Swift may bind to the extension implementation (static) instead of the conforming type’s method (dynamic through witness table).</li></ul><p>Rule of thumb:</p><ul><li>If you want dynamic behavior through <code>any P</code>, make it a <strong>protocol requirement</strong> and implement it in the conforming type.</li><li>Treat protocol extensions as <strong>shared helpers</strong>, not as “overridable defaults”.</li></ul><h3 id=some-vs-any-performance-intuition><code>some</code> vs <code>any</code> (performance intuition)<a hidden class=anchor aria-hidden=true href=#some-vs-any-performance-intuition>#</a></h3><ul><li><code>any P</code> (existential): runtime container + witness table lookup.</li><li><code>some P</code> (opaque): compiler knows the concrete type (per function boundary) → more optimization opportunities (specialization / inlining), often closer to static dispatch.</li></ul><h2 id=5-dangerous-corners--footguns>5. Dangerous corners / Footguns<a hidden class=anchor aria-hidden=true href=#5-dangerous-corners--footguns>#</a></h2><ul><li>⚠️ <strong>Protocol extension “override” illusion</strong>: methods in extensions are not truly overridable the way class methods are.</li><li>⚠️ <strong>Existentials hide concrete types</strong>: <code>any P</code> can introduce runtime costs and can change which implementation gets called.</li><li>⚠️ Overusing non-final classes can prevent optimizations (no devirtualization / inlining).</li><li>⚠️ <code>@objc dynamic</code> makes behavior swizzlable but reduces compile-time guarantees and performance.</li></ul><h2 id=6-when-should-i-use-which>6. When should I use which?<a hidden class=anchor aria-hidden=true href=#6-when-should-i-use-which>#</a></h2><ul><li>Prefer <strong>static dispatch</strong> by default:<ul><li>Use <code>struct</code>/<code>enum</code> for pure data + value semantics.</li><li>Mark classes/methods <code>final</code> unless you truly need inheritance.</li></ul></li><li>Use <strong>vtable dispatch</strong> when:<ul><li>You need runtime polymorphism via inheritance (<code>override</code>-based design).</li></ul></li><li>Use <strong>protocol dispatch</strong> when:<ul><li>You need abstraction and testability (DI), especially across module boundaries.</li><li>Prefer generics/<code>some P</code> when you want abstraction + performance.</li><li>Use <code>any P</code> when you need heterogenous collections, dynamic storage, or API surface that must hide types.</li></ul></li><li>Use <strong>Obj-C dispatch</strong> when:<ul><li>Interop with Objective-C runtime is required (KVO, swizzling, selectors, some UIKit patterns).</li></ul></li></ul><h2 id=7-30-second-summary>7. 30-second summary<a hidden class=anchor aria-hidden=true href=#7-30-second-summary>#</a></h2><ul><li><strong>If the compiler knows the exact target</strong> → direct (static) call.</li><li><strong>Classes with overrides</strong> → vtable.</li><li><strong>Protocol requirements via <code>any Protocol</code></strong> → witness table.</li><li><strong>Protocol extension methods</strong> → often static (watch out).</li><li><strong><code>some Protocol</code></strong> helps performance because the compiler can specialize/in-line.</li><li><strong><code>@objc dynamic</code></strong> uses Obj-C runtime dispatch: most flexible, least optimizable.</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/readme/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sametkoyuncu.github.io/swift-notes/>Swift Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>