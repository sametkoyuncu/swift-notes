<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Swift Notes</title>
<meta name=keywords content><meta name=description content="SwiftUI View Identity & Lifetime

What is it?

SwiftUI’s model where View values are cheap, ephemeral structs, while identity determines which underlying persistent backing store (state, subscriptions, render resources) is reused across updates. “Lifetime” is mostly about the lifetime of that backing store, not the View value.

What problem does it solve?

Enables a pure(ish) declarative UI where the framework can diff successive body results and update only what changed, while preserving state for “the same” conceptual view across recomputations."><meta name=author content><link rel=canonical href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/swiftui-view-identity-and-lifetime/><link crossorigin=anonymous href=https://sametkoyuncu.github.io/swift-notes/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://sametkoyuncu.github.io/swift-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sametkoyuncu.github.io/swift-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sametkoyuncu.github.io/swift-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://sametkoyuncu.github.io/swift-notes/apple-touch-icon.png><link rel=mask-icon href=https://sametkoyuncu.github.io/swift-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/swiftui-view-identity-and-lifetime/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/swiftui-view-identity-and-lifetime/"><meta property="og:site_name" content="Swift Notes"><meta property="og:title" content="Swift Notes"><meta property="og:description" content="SwiftUI View Identity & Lifetime
What is it? SwiftUI’s model where View values are cheap, ephemeral structs, while identity determines which underlying persistent backing store (state, subscriptions, render resources) is reused across updates. “Lifetime” is mostly about the lifetime of that backing store, not the View value.
What problem does it solve? Enables a pure(ish) declarative UI where the framework can diff successive body results and update only what changed, while preserving state for “the same” conceptual view across recomputations."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="cheat-sheets"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="SwiftUI View Identity & Lifetime

What is it?

SwiftUI’s model where View values are cheap, ephemeral structs, while identity determines which underlying persistent backing store (state, subscriptions, render resources) is reused across updates. “Lifetime” is mostly about the lifetime of that backing store, not the View value.

What problem does it solve?

Enables a pure(ish) declarative UI where the framework can diff successive body results and update only what changed, while preserving state for “the same” conceptual view across recomputations."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Cheat Sheets","item":"https://sametkoyuncu.github.io/swift-notes/cheat-sheets/"},{"@type":"ListItem","position":2,"name":"","item":"https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/swiftui-view-identity-and-lifetime/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"SwiftUI View Identity \u0026amp; Lifetime\nWhat is it? SwiftUI’s model where View values are cheap, ephemeral structs, while identity determines which underlying persistent backing store (state, subscriptions, render resources) is reused across updates. “Lifetime” is mostly about the lifetime of that backing store, not the View value.\nWhat problem does it solve? Enables a pure(ish) declarative UI where the framework can diff successive body results and update only what changed, while preserving state for “the same” conceptual view across recomputations.\n","keywords":[],"articleBody":"SwiftUI View Identity \u0026 Lifetime\nWhat is it? SwiftUI’s model where View values are cheap, ephemeral structs, while identity determines which underlying persistent backing store (state, subscriptions, render resources) is reused across updates. “Lifetime” is mostly about the lifetime of that backing store, not the View value.\nWhat problem does it solve? Enables a pure(ish) declarative UI where the framework can diff successive body results and update only what changed, while preserving state for “the same” conceptual view across recomputations.\nTypes / Categories • Structural identity: implied by position in the view tree (type + hierarchy + order). • Explicit identity: provided via .id(_:), ForEach(id:), Identifiable. • Stable vs unstable children: e.g. ForEach with stable IDs vs index-based iteration. • State storage kinds: • @State: per-view-identity local storage. • @StateObject: per-identity reference root, created once for that identity. • @ObservedObject: external reference, no ownership/creation semantics. • @EnvironmentObject / @Environment: keyed injection, independent of local identity. • @Binding: projection into some other storage, identity doesn’t own it.\nHow does it work in Swift? • body is recomputed frequently; treat it as a function of current inputs + state. • SwiftUI performs diffing between the old and new view trees; reuse hinges on matching identity. • Structural identity rules of thumb: • Same parent type + same child position + same child type ⇒ likely same identity. • Changing control flow (if/else, switch) can swap subtrees; identity may reset if the “slot” now holds a different type/branch. • .id(x): • Changes identity to be keyed by x. If x changes, SwiftUI treats it as a different view ⇒ state resets, onAppear/tasks may restart, animations can change. • ForEach: • With stable element IDs, SwiftUI can move/update rows without destroying state. • With unstable IDs (e.g. .self on non-stable values, or using indices), inserts/removes can shift identity and scramble per-row state. • Property wrappers tie state lifetime to identity: • @State is stored out-of-line; it persists only while the view identity persists. • @StateObject is initialized once per identity; if identity changes, it is recreated. • Closure capture vs view lifetime: • Closures in modifiers can capture old values; SwiftUI may keep them alive as long as the backing nodes live. Prefer deriving from state/inputs rather than caching. • Concurrency modifiers: • .task and .onAppear are coupled to backing node lifetime; identity changes can cancel/restart tasks.\nDangerous corners / Footguns • Accidental identity resets • Adding/removing wrappers (Group, AnyView, conditional modifiers) can change structural shape and reset @State. • Switching between different view types in an if often resets subtree state even if it “looks” the same. • Misusing .id • Using .id(UUID()) or other changing values forces rebuilds every update: state loss, task restarts, performance hits. • Tying .id to a frequently-changing input (e.g. text) can make the UI thrash. • Unstable ForEach IDs • Iterating over indices, or using .self for values that can collide/change, leads to state migration bugs (toggles flipping the wrong row, wrong animations). • @StateObject in the wrong place • Putting @StateObject in a view whose identity changes frequently causes repeated allocations and lost model state. • Initializing observable objects in init without stable identity expectations often surprises you. • Hidden lifetime extensions • Long-running .task work capturing self or models can keep graphs alive; cancellation only happens when node is removed / identity changes. • EquatableView / .equatable() misunderstandings • Preventing updates doesn’t guarantee lifetime changes won’t occur; it only short-circuits some diffing when equality holds.\nWhen should I use which? • Rely on structural identity when the tree shape is stable and you want SwiftUI’s default behavior (most cases). • Use explicit IDs when: • You need stable state per logical item across moves/inserts/removes (ForEach with stable IDs). • You intentionally want to reset a subtree (e.g. “new document/session”). • Prefer ForEach(data, id:) with a real stable ID (database ID, UUID stored in model), not indices. • Use @State for small, view-local, value-type state tied to that view’s identity. • Use @StateObject for a reference model the view owns and that must be created once per identity (root of a feature, row view model with stable row identity). • Use @ObservedObject / @Binding when ownership is external and identity should not control creation/destruction. • Use .id sparingly; treat it like “invalidate and recreate this subtree.”\n30-second summary\nSwiftUI View structs are transient; the persistent stuff lives behind the scenes and is keyed by view identity. Identity is usually structural (type + position), but you can override it with stable IDs (ForEach, .id). If identity changes, @State/@StateObject reset and appearance/tasks can restart. Most bugs come from unstable IDs, index-based lists, and unintended tree-shape/type changes.\n","wordCount":"778","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/swiftui-view-identity-and-lifetime/"},"publisher":{"@type":"Organization","name":"Swift Notes","logo":{"@type":"ImageObject","url":"https://sametkoyuncu.github.io/swift-notes/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://sametkoyuncu.github.io/swift-notes/ accesskey=h title="Swift Notes (Alt + H)">Swift Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sametkoyuncu.github.io/swift-notes/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/ title="Cheat Sheets"><span>Cheat Sheets</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sametkoyuncu.github.io/swift-notes/>Home</a>&nbsp;»&nbsp;<a href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/>Cheat Sheets</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta><span>4 min</span></div></header><div class=post-content><p>SwiftUI View Identity & Lifetime</p><ol><li>What is it?</li></ol><p>SwiftUI’s model where View values are cheap, ephemeral structs, while identity determines which underlying persistent backing store (state, subscriptions, render resources) is reused across updates. “Lifetime” is mostly about the lifetime of that backing store, not the View value.</p><ol start=2><li>What problem does it solve?</li></ol><p>Enables a pure(ish) declarative UI where the framework can diff successive body results and update only what changed, while preserving state for “the same” conceptual view across recomputations.</p><ol start=3><li><p>Types / Categories
• Structural identity: implied by position in the view tree (type + hierarchy + order).
• Explicit identity: provided via .id(_:), ForEach(id:), Identifiable.
• Stable vs unstable children: e.g. ForEach with stable IDs vs index-based iteration.
• State storage kinds:
• @State: per-view-identity local storage.
• @StateObject: per-identity reference root, created once for that identity.
• @ObservedObject: external reference, no ownership/creation semantics.
• @EnvironmentObject / @Environment: keyed injection, independent of local identity.
• @Binding: projection into some other storage, identity doesn’t own it.</p></li><li><p>How does it work in Swift?
• body is recomputed frequently; treat it as a function of current inputs + state.
• SwiftUI performs diffing between the old and new view trees; reuse hinges on matching identity.
• Structural identity rules of thumb:
• Same parent type + same child position + same child type ⇒ likely same identity.
• Changing control flow (if/else, switch) can swap subtrees; identity may reset if the “slot” now holds a different type/branch.
• .id(x):
• Changes identity to be keyed by x. If x changes, SwiftUI treats it as a different view ⇒ state resets, onAppear/tasks may restart, animations can change.
• ForEach:
• With stable element IDs, SwiftUI can move/update rows without destroying state.
• With unstable IDs (e.g. .self on non-stable values, or using indices), inserts/removes can shift identity and scramble per-row state.
• Property wrappers tie state lifetime to identity:
• @State is stored out-of-line; it persists only while the view identity persists.
• @StateObject is initialized once per identity; if identity changes, it is recreated.
• Closure capture vs view lifetime:
• Closures in modifiers can capture old values; SwiftUI may keep them alive as long as the backing nodes live. Prefer deriving from state/inputs rather than caching.
• Concurrency modifiers:
• .task and .onAppear are coupled to backing node lifetime; identity changes can cancel/restart tasks.</p></li><li><p>Dangerous corners / Footguns
• Accidental identity resets
• Adding/removing wrappers (Group, AnyView, conditional modifiers) can change structural shape and reset @State.
• Switching between different view types in an if often resets subtree state even if it “looks” the same.
• Misusing .id
• Using .id(UUID()) or other changing values forces rebuilds every update: state loss, task restarts, performance hits.
• Tying .id to a frequently-changing input (e.g. text) can make the UI thrash.
• Unstable ForEach IDs
• Iterating over indices, or using .self for values that can collide/change, leads to state migration bugs (toggles flipping the wrong row, wrong animations).
• @StateObject in the wrong place
• Putting @StateObject in a view whose identity changes frequently causes repeated allocations and lost model state.
• Initializing observable objects in init without stable identity expectations often surprises you.
• Hidden lifetime extensions
• Long-running .task work capturing self or models can keep graphs alive; cancellation only happens when node is removed / identity changes.
• EquatableView / .equatable() misunderstandings
• Preventing updates doesn’t guarantee lifetime changes won’t occur; it only short-circuits some diffing when equality holds.</p></li><li><p>When should I use which?
• Rely on structural identity when the tree shape is stable and you want SwiftUI’s default behavior (most cases).
• Use explicit IDs when:
• You need stable state per logical item across moves/inserts/removes (ForEach with stable IDs).
• You intentionally want to reset a subtree (e.g. “new document/session”).
• Prefer ForEach(data, id:) with a real stable ID (database ID, UUID stored in model), not indices.
• Use @State for small, view-local, value-type state tied to that view’s identity.
• Use @StateObject for a reference model the view owns and that must be created once per identity (root of a feature, row view model with stable row identity).
• Use @ObservedObject / @Binding when ownership is external and identity should not control creation/destruction.
• Use .id sparingly; treat it like “invalidate and recreate this subtree.”</p></li><li><p>30-second summary</p></li></ol><p>SwiftUI View structs are transient; the persistent stuff lives behind the scenes and is keyed by view identity. Identity is usually structural (type + position), but you can override it with stable IDs (ForEach, .id). If identity changes, @State/@StateObject reset and appearance/tasks can restart. Most bugs come from unstable IDs, index-based lists, and unintended tree-shape/type changes.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/some-vs-any/><span class=title>« Prev</span><br><span></span>
</a><a class=next href=https://sametkoyuncu.github.io/swift-notes/notes/items/associated-types/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sametkoyuncu.github.io/swift-notes/>Swift Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>