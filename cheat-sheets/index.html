<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cheat Sheets | Swift Notes</title>
<meta name=keywords content><meta name=description content="Swift quick-reference sheets pulled straight from the repo."><meta name=author content><link rel=canonical href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/><link crossorigin=anonymous href=https://sametkoyuncu.github.io/swift-notes/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://sametkoyuncu.github.io/swift-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sametkoyuncu.github.io/swift-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sametkoyuncu.github.io/swift-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://sametkoyuncu.github.io/swift-notes/apple-touch-icon.png><link rel=mask-icon href=https://sametkoyuncu.github.io/swift-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/index.xml title=rss><link rel=alternate hreflang=en href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://sametkoyuncu.github.io/swift-notes/cheat-sheets/"><meta property="og:site_name" content="Swift Notes"><meta property="og:title" content="Cheat Sheets"><meta property="og:description" content="Swift quick-reference sheets pulled straight from the repo."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cheat Sheets"><meta name=twitter:description content="Swift quick-reference sheets pulled straight from the repo."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Cheat Sheets","item":"https://sametkoyuncu.github.io/swift-notes/cheat-sheets/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://sametkoyuncu.github.io/swift-notes/ accesskey=h title="Swift Notes (Alt + H)">Swift Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sametkoyuncu.github.io/swift-notes/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/ title="Cheat Sheets"><span class=active>Cheat Sheets</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://sametkoyuncu.github.io/swift-notes/>Home</a></div><h1>Cheat Sheets</h1><div class=post-description>Swift quick-reference sheets pulled straight from the repo.</div></header><div class=post-content><p>Fast, high-signal Swift cheat sheets for everyday reference. These pages are sourced from <code>cheat-sheets/</code> and stay in sync with the repo—scan the list below or search to find the snippet you need.</p></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Dispatch (Swift) 1. What is it? Dispatch is the mechanism that decides which implementation a call will execute (and when that decision is made: compile-time vs runtime). In Swift, dispatch choices directly affect polymorphism, correctness (especially with protocol extensions), and performance.
2. What problem does it solve? Enables polymorphism (same call, different behavior) via inheritance or protocols. Balances flexibility vs performance (dynamic lookup vs direct calls). Defines how overrides, protocol conformances, and runtime features (KVO/swizzling) work. 3. Types / Categories Kind Trigger / Where it appears Mechanism Typical cost Notes Static dispatch (direct call) struct/enum, final methods/classes, static functions, many generics Compiler emits a direct call Lowest Most optimizable (inline, specialize) Virtual dispatch (vtable) class inheritance + overridable methods vtable lookup Low–medium Enables override polymorphism Protocol dispatch (witness table) Calling protocol requirements through a protocol type witness table lookup Low–medium Key for any Protocol calls Obj-C message dispatch @objc dynamic, KVC/KVO, swizzling, selectors objc_msgSend Medium–high Most dynamic, least optimizable 4. How does it work in Swift? Quick decision tree Value types (struct/enum) → usually static dispatch final class or final func → static dispatch (cannot be overridden) Non-final class methods (especially overridden) → vtable dispatch Protocol requirement calls via any Protocol → witness table dispatch Protocol extension methods → static dispatch (common footgun) Generic T: Protocol → often specialized by the compiler → can become close to static dispatch @objc dynamic → Objective-C runtime dispatch (objc_msgSend) Why protocol extensions can surprise you A method implemented in a protocol extension is not always dispatched through the witness table. If you call it via an existential (let x: any P = ...), Swift may bind to the extension implementation (static) instead of the conforming type’s method (dynamic through witness table). Rule of thumb:
...</p></div><footer class=entry-footer><span>3 min</span></footer><a class=entry-link aria-label="post link to " href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/dispatch/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Cheat Sheets All cheat sheets follow a strict, shared structure. Each document is designed for quick recall rather than full tutorials.
If you are adding a new cheat sheet:
Use the template in cheat-sheets/_template.md Keep it under 1–2 screens Focus on “why” and “when”, not syntax</p></div><footer class=entry-footer><span>1 min</span></footer><a class=entry-link aria-label="post link to " href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/readme/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>some vs any (Opaque vs Existential) 1. What is it? some defines an opaque type: the concrete type is fixed but hidden from the caller.
any defines an existential type: the concrete type is erased and can vary at runtime.
2. What problem does it solve? They let APIs abstract over types:
some: abstraction without losing static type information any: abstraction when heterogeneity or runtime flexibility is required 3. Types / Categories Opaque types (some P) Compile-time concrete type Single underlying type per declaration Existential types (any P) Runtime type-erased container Can hold multiple concrete types over time 4. How does it work in Swift? some P Compiler generates a hidden concrete generic Uses static dispatch, specialization, and inlining Backed by vtables/witness tables known at compile time any P Stored as an existential container Uses dynamic dispatch via witness tables May allocate (inline buffer vs heap) depending on size 5. Dangerous corners / Footguns some cannot return different concrete types across branches any loses associated type and Self information Existentials inhibit specialization and inlining Existential boxing can cause unexpected heap allocations Mixing any P with generics often causes silent performance cliffs 6. When should I use which? Use some when: You control the implementation You want abstraction and performance The concrete type is stable per API Use any when: You need heterogenous collections The concrete type varies at runtime API boundaries require type erasure Prefer generics over any when the caller can benefit from specialization 7. 30-second summary some = hidden concrete type, fast, statically dispatched any = type-erased container, flexible, dynamically dispatched some preserves optimization; any trades performance for flexibility Default to some (or generics); reach for any only when necessary</p></div><footer class=entry-footer><span>2 min</span></footer><a class=entry-link aria-label="post link to " href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/some-vs-any/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>SwiftUI View Identity & Lifetime
What is it? SwiftUI’s model where View values are cheap, ephemeral structs, while identity determines which underlying persistent backing store (state, subscriptions, render resources) is reused across updates. “Lifetime” is mostly about the lifetime of that backing store, not the View value.
What problem does it solve? Enables a pure(ish) declarative UI where the framework can diff successive body results and update only what changed, while preserving state for “the same” conceptual view across recomputations.
...</p></div><footer class=entry-footer><span>4 min</span></footer><a class=entry-link aria-label="post link to " href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/items/swiftui-view-identity-and-lifetime/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://sametkoyuncu.github.io/swift-notes/>Swift Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>