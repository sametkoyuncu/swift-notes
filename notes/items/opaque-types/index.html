<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Swift Notes</title>
<meta name=keywords content><meta name=description content="Opaque Types in Swift
Swift&rsquo;s some keyword lets you return a value whose concrete type stays hidden while still preserving type safety. It behaves like the inverse of any: callers know there is a specific type, but they only interact with the protocol requirements that type satisfies.
Why Use Opaque Return Types?

Hide implementation details while keeping static dispatch and optimizations.
Avoid exposing long generic signatures from helper methods.
Keep flexibility to swap implementations without breaking API callers.

Basic Example


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22


protocol Shape {
    func area() -> Double
}

struct Square: Shape {
    let edge: Double
    func area() -> Double { edge * edge }
}

struct Circle: Shape {
    let radius: Double
    func area() -> Double { Double.pi * radius * radius }
}

// Only promise that the result conforms to Shape; callers do not know if it is a Circle or Square.
func makeUnitSquare() -> some Shape {
    Square(edge: 1)
}

func makeCircle(radius: Double) -> some Shape {
    Circle(radius: radius)
}


Opaque types guarantee that each function returns a single concrete type. makeUnitSquare() always yields Square, while makeCircle(radius:) always yields Circle for any radius value."><meta name=author content><link rel=canonical href=https://sametkoyuncu.github.io/swift-notes/notes/items/opaque-types/><link crossorigin=anonymous href=https://sametkoyuncu.github.io/swift-notes/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://sametkoyuncu.github.io/swift-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sametkoyuncu.github.io/swift-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sametkoyuncu.github.io/swift-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://sametkoyuncu.github.io/swift-notes/apple-touch-icon.png><link rel=mask-icon href=https://sametkoyuncu.github.io/swift-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sametkoyuncu.github.io/swift-notes/notes/items/opaque-types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://sametkoyuncu.github.io/swift-notes/notes/items/opaque-types/"><meta property="og:site_name" content="Swift Notes"><meta property="og:title" content="Swift Notes"><meta property="og:description" content="Opaque Types in Swift Swift’s some keyword lets you return a value whose concrete type stays hidden while still preserving type safety. It behaves like the inverse of any: callers know there is a specific type, but they only interact with the protocol requirements that type satisfies.
Why Use Opaque Return Types? Hide implementation details while keeping static dispatch and optimizations. Avoid exposing long generic signatures from helper methods. Keep flexibility to swap implementations without breaking API callers. Basic Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 protocol Shape { func area() -> Double } struct Square: Shape { let edge: Double func area() -> Double { edge * edge } } struct Circle: Shape { let radius: Double func area() -> Double { Double.pi * radius * radius } } // Only promise that the result conforms to Shape; callers do not know if it is a Circle or Square. func makeUnitSquare() -> some Shape { Square(edge: 1) } func makeCircle(radius: Double) -> some Shape { Circle(radius: radius) } Opaque types guarantee that each function returns a single concrete type. makeUnitSquare() always yields Square, while makeCircle(radius:) always yields Circle for any radius value."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Opaque Types in Swift
Swift&rsquo;s some keyword lets you return a value whose concrete type stays hidden while still preserving type safety. It behaves like the inverse of any: callers know there is a specific type, but they only interact with the protocol requirements that type satisfies.
Why Use Opaque Return Types?

Hide implementation details while keeping static dispatch and optimizations.
Avoid exposing long generic signatures from helper methods.
Keep flexibility to swap implementations without breaking API callers.

Basic Example


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22


protocol Shape {
    func area() -> Double
}

struct Square: Shape {
    let edge: Double
    func area() -> Double { edge * edge }
}

struct Circle: Shape {
    let radius: Double
    func area() -> Double { Double.pi * radius * radius }
}

// Only promise that the result conforms to Shape; callers do not know if it is a Circle or Square.
func makeUnitSquare() -> some Shape {
    Square(edge: 1)
}

func makeCircle(radius: Double) -> some Shape {
    Circle(radius: radius)
}


Opaque types guarantee that each function returns a single concrete type. makeUnitSquare() always yields Square, while makeCircle(radius:) always yields Circle for any radius value."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://sametkoyuncu.github.io/swift-notes/notes/"},{"@type":"ListItem","position":2,"name":"","item":"https://sametkoyuncu.github.io/swift-notes/notes/items/opaque-types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Opaque Types in Swift Swift\u0026rsquo;s some keyword lets you return a value whose concrete type stays hidden while still preserving type safety. It behaves like the inverse of any: callers know there is a specific type, but they only interact with the protocol requirements that type satisfies.\nWhy Use Opaque Return Types? Hide implementation details while keeping static dispatch and optimizations. Avoid exposing long generic signatures from helper methods. Keep flexibility to swap implementations without breaking API callers. Basic Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 protocol Shape { func area() -\u0026gt; Double } struct Square: Shape { let edge: Double func area() -\u0026gt; Double { edge * edge } } struct Circle: Shape { let radius: Double func area() -\u0026gt; Double { Double.pi * radius * radius } } // Only promise that the result conforms to Shape; callers do not know if it is a Circle or Square. func makeUnitSquare() -\u0026gt; some Shape { Square(edge: 1) } func makeCircle(radius: Double) -\u0026gt; some Shape { Circle(radius: radius) } Opaque types guarantee that each function returns a single concrete type. makeUnitSquare() always yields Square, while makeCircle(radius:) always yields Circle for any radius value.\n","keywords":[],"articleBody":"Opaque Types in Swift Swift’s some keyword lets you return a value whose concrete type stays hidden while still preserving type safety. It behaves like the inverse of any: callers know there is a specific type, but they only interact with the protocol requirements that type satisfies.\nWhy Use Opaque Return Types? Hide implementation details while keeping static dispatch and optimizations. Avoid exposing long generic signatures from helper methods. Keep flexibility to swap implementations without breaking API callers. Basic Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 protocol Shape { func area() -\u003e Double } struct Square: Shape { let edge: Double func area() -\u003e Double { edge * edge } } struct Circle: Shape { let radius: Double func area() -\u003e Double { Double.pi * radius * radius } } // Only promise that the result conforms to Shape; callers do not know if it is a Circle or Square. func makeUnitSquare() -\u003e some Shape { Square(edge: 1) } func makeCircle(radius: Double) -\u003e some Shape { Circle(radius: radius) } Opaque types guarantee that each function returns a single concrete type. makeUnitSquare() always yields Square, while makeCircle(radius:) always yields Circle for any radius value.\nOpaque Types vs Protocol Existentials (any) some preserves the concrete type across the call site (the compiler still knows it), enabling inlining and overload resolution. any erases the type entirely, so value semantics like Self requirements or associated types become unavailable. For performance-critical code—such as a frequently reused builder—some typically avoids the dynamic dispatch overhead of any. Working with Associated Types Protocols with associated types cannot be used directly as return types. Opaque types let you expose them safely:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protocol DataProvider { associatedtype Item func items() -\u003e [Item] } struct LocalProvider: DataProvider { func items() -\u003e [String] { [\"alpha\", \"beta\"] } } struct RemoteProvider: DataProvider { func items() -\u003e [Int] { [1, 2, 3] } } // Callers only need to know it is a DataProvider; they do not care about Item. func buildLocalProvider() -\u003e some DataProvider { LocalProvider() } Because buildLocalProvider() always returns a LocalProvider, the compiler can resolve Item as String internally without exposing it to callers.\nComposing Views In SwiftUI, opaque types keep view hierarchies short and expressive:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct MessageRow: View { let isOwnMessage: Bool var body: some View { HStack { if isOwnMessage { Spacer() bubble(color: .blue.opacity(0.2)) } else { bubble(color: .gray.opacity(0.15)) Spacer() } } .padding(.horizontal) } private func bubble(color: Color) -\u003e some View { Text(\"Hello\") .padding(12) .background(color) .clipShape(RoundedRectangle(cornerRadius: 12)) } } Returning some View from bubble(color:) hides the exact view composition (text + padding + background) while enabling SwiftUI’s diffing engine to optimize the layout.\nSwapping Implementations Without Breaking Callers Opaque types let you change the concrete return type without modifying call sites, as long as the returned value still conforms to the declared protocol:\n1 2 3 4 // Initially returns LocalProvider func provider(for offlineMode: Bool) -\u003e some DataProvider { offlineMode ? LocalProvider() : RemoteProvider() } The compiler rejects this implementation because the function would return two concrete types. A common fix is to wrap the types to ensure a single concrete return:\n1 2 3 4 5 6 7 8 9 10 11 12 struct AnyProvider\u003cItem\u003e: DataProvider { private let _items: () -\u003e [Item] init\u003cP: DataProvider\u003e(_ provider: P) where P.Item == Item { _items = provider.items } func items() -\u003e [Item] { _items() } } func provider(for offlineMode: Bool) -\u003e some DataProvider { let provider: AnyProvider\u003cString\u003e = offlineMode ? AnyProvider(LocalProvider()) : AnyProvider(LocalProvider()) // Replace with RemoteProvider() after aligning Item return provider } The key rule: each opaque-returning function must always produce the same concrete type, even though callers only see the protocol surface.\nTesting Tips Use type(of:) inside tests to confirm the concrete type stays stable after refactors. Benchmark some versus any where performance matters; opaque types often remove dynamic dispatch costs. In SwiftUI previews, keep helper builders private and opaque to minimize rebuild churn when iterating on the design. Further Reading Swift Language Reference – Opaque Types WWDC19 – Opaque Types and the Swift type system ","wordCount":"721","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sametkoyuncu.github.io/swift-notes/notes/items/opaque-types/"},"publisher":{"@type":"Organization","name":"Swift Notes","logo":{"@type":"ImageObject","url":"https://sametkoyuncu.github.io/swift-notes/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://sametkoyuncu.github.io/swift-notes/ accesskey=h title="Swift Notes (Alt + H)">Swift Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sametkoyuncu.github.io/swift-notes/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://sametkoyuncu.github.io/swift-notes/cheat-sheets/ title="Cheat Sheets"><span>Cheat Sheets</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sametkoyuncu.github.io/swift-notes/>Home</a>&nbsp;»&nbsp;<a href=https://sametkoyuncu.github.io/swift-notes/notes/>Notes</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta><span>4 min</span></div></header><div class=post-content><h1 id=opaque-types-in-swift>Opaque Types in Swift<a hidden class=anchor aria-hidden=true href=#opaque-types-in-swift>#</a></h1><p>Swift&rsquo;s <code>some</code> keyword lets you return a value whose concrete type stays hidden while still preserving type safety. It behaves like the inverse of <code>any</code>: callers know there is a specific type, but they only interact with the protocol requirements that type satisfies.</p><h2 id=why-use-opaque-return-types>Why Use Opaque Return Types?<a hidden class=anchor aria-hidden=true href=#why-use-opaque-return-types>#</a></h2><ul><li>Hide implementation details while keeping static dispatch and optimizations.</li><li>Avoid exposing long generic signatures from helper methods.</li><li>Keep flexibility to swap implementations without breaking API callers.</li></ul><h2 id=basic-example>Basic Example<a hidden class=anchor aria-hidden=true href=#basic-example>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>protocol</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>func</span> <span class=nf>area</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=nb>Double</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Square</span><span class=p>:</span> <span class=n>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>edge</span><span class=p>:</span> <span class=nb>Double</span>
</span></span><span class=line><span class=cl>    <span class=kd>func</span> <span class=nf>area</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=nb>Double</span> <span class=p>{</span> <span class=n>edge</span> <span class=o>*</span> <span class=n>edge</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Circle</span><span class=p>:</span> <span class=n>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>radius</span><span class=p>:</span> <span class=nb>Double</span>
</span></span><span class=line><span class=cl>    <span class=kd>func</span> <span class=nf>area</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=nb>Double</span> <span class=p>{</span> <span class=nb>Double</span><span class=p>.</span><span class=n>pi</span> <span class=o>*</span> <span class=n>radius</span> <span class=o>*</span> <span class=n>radius</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Only promise that the result conforms to Shape; callers do not know if it is a Circle or Square.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>makeUnitSquare</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=n>some</span> <span class=n>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Square</span><span class=p>(</span><span class=n>edge</span><span class=p>:</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>makeCircle</span><span class=p>(</span><span class=n>radius</span><span class=p>:</span> <span class=nb>Double</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>some</span> <span class=n>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Circle</span><span class=p>(</span><span class=n>radius</span><span class=p>:</span> <span class=n>radius</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Opaque types guarantee that each function returns a single concrete type. <code>makeUnitSquare()</code> always yields <code>Square</code>, while <code>makeCircle(radius:)</code> always yields <code>Circle</code> for any radius value.</p><h2 id=opaque-types-vs-protocol-existentials-any>Opaque Types vs Protocol Existentials (<code>any</code>)<a hidden class=anchor aria-hidden=true href=#opaque-types-vs-protocol-existentials-any>#</a></h2><ul><li><code>some</code> preserves the concrete type across the call site (the compiler still knows it), enabling inlining and overload resolution.</li><li><code>any</code> erases the type entirely, so value semantics like <code>Self</code> requirements or associated types become unavailable.</li><li>For performance-critical code—such as a frequently reused builder—<code>some</code> typically avoids the dynamic dispatch overhead of <code>any</code>.</li></ul><h2 id=working-with-associated-types>Working with Associated Types<a hidden class=anchor aria-hidden=true href=#working-with-associated-types>#</a></h2><p>Protocols with associated types cannot be used directly as return types. Opaque types let you expose them safely:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>protocol</span> <span class=nc>DataProvider</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>associatedtype</span> <span class=n>Item</span>
</span></span><span class=line><span class=cl>    <span class=kd>func</span> <span class=nf>items</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>[</span><span class=n>Item</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>LocalProvider</span><span class=p>:</span> <span class=n>DataProvider</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>func</span> <span class=nf>items</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>[</span><span class=nb>String</span><span class=p>]</span> <span class=p>{</span> <span class=p>[</span><span class=s>&#34;alpha&#34;</span><span class=p>,</span> <span class=s>&#34;beta&#34;</span><span class=p>]</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>RemoteProvider</span><span class=p>:</span> <span class=n>DataProvider</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>func</span> <span class=nf>items</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>[</span><span class=nb>Int</span><span class=p>]</span> <span class=p>{</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Callers only need to know it is a DataProvider; they do not care about Item.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>buildLocalProvider</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=n>some</span> <span class=n>DataProvider</span> <span class=p>{</span> <span class=n>LocalProvider</span><span class=p>()</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Because <code>buildLocalProvider()</code> always returns a <code>LocalProvider</code>, the compiler can resolve <code>Item</code> as <code>String</code> internally without exposing it to callers.</p><h2 id=composing-views>Composing Views<a hidden class=anchor aria-hidden=true href=#composing-views>#</a></h2><p>In SwiftUI, opaque types keep view hierarchies short and expressive:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>MessageRow</span><span class=p>:</span> <span class=n>View</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>isOwnMessage</span><span class=p>:</span> <span class=nb>Bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nv>body</span><span class=p>:</span> <span class=n>some</span> <span class=n>View</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>HStack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>isOwnMessage</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Spacer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=n>bubble</span><span class=p>(</span><span class=n>color</span><span class=p>:</span> <span class=p>.</span><span class=n>blue</span><span class=p>.</span><span class=n>opacity</span><span class=p>(</span><span class=mf>0.2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>bubble</span><span class=p>(</span><span class=n>color</span><span class=p>:</span> <span class=p>.</span><span class=n>gray</span><span class=p>.</span><span class=n>opacity</span><span class=p>(</span><span class=mf>0.15</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>Spacer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>padding</span><span class=p>(.</span><span class=n>horizontal</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>func</span> <span class=nf>bubble</span><span class=p>(</span><span class=n>color</span><span class=p>:</span> <span class=n>Color</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>some</span> <span class=n>View</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Text</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>padding</span><span class=p>(</span><span class=mi>12</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>background</span><span class=p>(</span><span class=n>color</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>clipShape</span><span class=p>(</span><span class=n>RoundedRectangle</span><span class=p>(</span><span class=n>cornerRadius</span><span class=p>:</span> <span class=mi>12</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Returning <code>some View</code> from <code>bubble(color:)</code> hides the exact view composition (text + padding + background) while enabling SwiftUI&rsquo;s diffing engine to optimize the layout.</p><h2 id=swapping-implementations-without-breaking-callers>Swapping Implementations Without Breaking Callers<a hidden class=anchor aria-hidden=true href=#swapping-implementations-without-breaking-callers>#</a></h2><p>Opaque types let you change the concrete return type without modifying call sites, as long as the returned value still conforms to the declared protocol:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=c1>// Initially returns LocalProvider</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>provider</span><span class=p>(</span><span class=k>for</span> <span class=n>offlineMode</span><span class=p>:</span> <span class=nb>Bool</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>some</span> <span class=n>DataProvider</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>offlineMode</span> <span class=p>?</span> <span class=n>LocalProvider</span><span class=p>()</span> <span class=p>:</span> <span class=n>RemoteProvider</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The compiler rejects this implementation because the function would return two concrete types. A common fix is to wrap the types to ensure a single concrete return:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>AnyProvider</span><span class=p>&lt;</span><span class=n>Item</span><span class=p>&gt;:</span> <span class=n>DataProvider</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>let</span> <span class=nv>_items</span><span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>[</span><span class=n>Item</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=kd>init</span><span class=p>&lt;</span><span class=n>P</span><span class=p>:</span> <span class=n>DataProvider</span><span class=p>&gt;(</span><span class=kc>_</span> <span class=n>provider</span><span class=p>:</span> <span class=n>P</span><span class=p>)</span> <span class=k>where</span> <span class=n>P</span><span class=p>.</span><span class=n>Item</span> <span class=p>==</span> <span class=n>Item</span> <span class=p>{</span> <span class=n>_items</span> <span class=p>=</span> <span class=n>provider</span><span class=p>.</span><span class=n>items</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>func</span> <span class=nf>items</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>[</span><span class=n>Item</span><span class=p>]</span> <span class=p>{</span> <span class=n>_items</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>provider</span><span class=p>(</span><span class=k>for</span> <span class=n>offlineMode</span><span class=p>:</span> <span class=nb>Bool</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>some</span> <span class=n>DataProvider</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>provider</span><span class=p>:</span> <span class=n>AnyProvider</span><span class=p>&lt;</span><span class=nb>String</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>offlineMode</span>
</span></span><span class=line><span class=cl>        <span class=p>?</span> <span class=n>AnyProvider</span><span class=p>(</span><span class=n>LocalProvider</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=n>AnyProvider</span><span class=p>(</span><span class=n>LocalProvider</span><span class=p>())</span> <span class=c1>// Replace with RemoteProvider() after aligning Item</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>provider</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The key rule: each opaque-returning function must always produce the same concrete type, even though callers only see the protocol surface.</p><h2 id=testing-tips>Testing Tips<a hidden class=anchor aria-hidden=true href=#testing-tips>#</a></h2><ul><li>Use <code>type(of:)</code> inside tests to confirm the concrete type stays stable after refactors.</li><li>Benchmark <code>some</code> versus <code>any</code> where performance matters; opaque types often remove dynamic dispatch costs.</li><li>In SwiftUI previews, keep helper builders <code>private</code> and opaque to minimize rebuild churn when iterating on the design.</li></ul><h2 id=further-reading>Further Reading<a hidden class=anchor aria-hidden=true href=#further-reading>#</a></h2><ul><li><a href=https://docs.swift.org/swift-book/documentation/the-swift-programming-language/opaquetypes>Swift Language Reference – Opaque Types</a></li><li><a href=https://developer.apple.com/videos/play/wwdc2019/414/>WWDC19 – Opaque Types and the Swift type system</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://sametkoyuncu.github.io/swift-notes/notes/items/observation-macros/><span class=title>« Prev</span><br><span></span>
</a><a class=next href=https://sametkoyuncu.github.io/swift-notes/notes/items/programmatic-ui/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sametkoyuncu.github.io/swift-notes/>Swift Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>