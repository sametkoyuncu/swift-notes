<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Swift Notes</title>
<meta name=keywords content><meta name=description content="Collections and Algorithms (with version cues)
Sequence vs Collection, common transforms, and performance considerations.
Version Quick Reference

Swift 5.x+: standard library offers CoW collections, lazy views, and SIMD-backed ContiguousArray.
Swift 5.7+: improved type inference with primary associated types; any spelling required for existentials.
Swift 5.9+: parameter packs/variadic generics (advanced; not covered here).

Sequence vs Collection

Sequence: single-pass iteration guaranteed; may be destructive. Use when you don’t need indices or multiple passes.
Collection: multi-pass with stable indices (startIndex/endIndex). Prefer for in-memory data you traverse multiple times.

Common Transforms

map/compactMap/flatMap: convert, filter nils, flatten.
filter: keep matching elements; be mindful of allocation on large data.
reduce: combine into a single value; prefer reduce(into:) to avoid intermediate allocations.



1
2
3
4


let upper = names.map { $0.uppercased() }
let numbers = strings.compactMap(Int.init)
let flattened = [[1,2],[3]].flatMap { $0 }
let counts = words.reduce(into: [:]) { $0[$1, default: 0] += 1 }


Lazy Views

Use .lazy to defer work and reduce intermediate allocations, especially after filters and maps chained together.



1


let firstBig = numbers.lazy.filter { $0 > 1000 }.first


Slicing and Subsequence

Slices (ArraySlice, Substring) share storage with the base collection; copy to Array/String if you need long-term storage.



1
2


let slice = array[2...]      // ArraySlice
let copy = Array(slice)      // makes an owned copy


Sorting and Searching

sorted() returns a new array; sort() mutates in-place (more memory efficient).
For membership checks on large datasets, consider Set or Dictionary over linear contains.

Mutations and Performance

Prefer reserveCapacity on arrays and dictionaries when size is known to reduce reallocations.
For hot paths, avoid repeated removeFirst() on arrays (O(n)); use indices or popLast() where order permits.

Algorithms to Remember

zip to iterate pairs; stride(from:to:by:) for steps; prefix/while, drop/while for stream-like processing.
grouping via Dictionary(grouping:by:); chunks manually via stride or rolling indices.

Testing

Add property-based checks (if available) for algorithms to ensure invariants (e.g., sorted output length matches input).
Benchmark critical paths with measure in XCTest or simple timing helpers; ensure lazy vs eager choices are intentional.
"><meta name=author content><link rel=canonical href=https://sametkoyuncu.github.io/swift-notes/notes/items/collections-and-algorithms/><link crossorigin=anonymous href=../../../swift-notes/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://sametkoyuncu.github.io/swift-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sametkoyuncu.github.io/swift-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sametkoyuncu.github.io/swift-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://sametkoyuncu.github.io/swift-notes/apple-touch-icon.png><link rel=mask-icon href=https://sametkoyuncu.github.io/swift-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sametkoyuncu.github.io/swift-notes/notes/items/collections-and-algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://sametkoyuncu.github.io/swift-notes/notes/items/collections-and-algorithms/"><meta property="og:site_name" content="Swift Notes"><meta property="og:title" content="Swift Notes"><meta property="og:description" content="Collections and Algorithms (with version cues) Sequence vs Collection, common transforms, and performance considerations.
Version Quick Reference Swift 5.x+: standard library offers CoW collections, lazy views, and SIMD-backed ContiguousArray. Swift 5.7+: improved type inference with primary associated types; any spelling required for existentials. Swift 5.9+: parameter packs/variadic generics (advanced; not covered here). Sequence vs Collection Sequence: single-pass iteration guaranteed; may be destructive. Use when you don’t need indices or multiple passes. Collection: multi-pass with stable indices (startIndex/endIndex). Prefer for in-memory data you traverse multiple times. Common Transforms map/compactMap/flatMap: convert, filter nils, flatten. filter: keep matching elements; be mindful of allocation on large data. reduce: combine into a single value; prefer reduce(into:) to avoid intermediate allocations. 1 2 3 4 let upper = names.map { $0.uppercased() } let numbers = strings.compactMap(Int.init) let flattened = [[1,2],[3]].flatMap { $0 } let counts = words.reduce(into: [:]) { $0[$1, default: 0] += 1 } Lazy Views Use .lazy to defer work and reduce intermediate allocations, especially after filters and maps chained together. 1 let firstBig = numbers.lazy.filter { $0 > 1000 }.first Slicing and Subsequence Slices (ArraySlice, Substring) share storage with the base collection; copy to Array/String if you need long-term storage. 1 2 let slice = array[2...] // ArraySlice let copy = Array(slice) // makes an owned copy Sorting and Searching sorted() returns a new array; sort() mutates in-place (more memory efficient). For membership checks on large datasets, consider Set or Dictionary over linear contains. Mutations and Performance Prefer reserveCapacity on arrays and dictionaries when size is known to reduce reallocations. For hot paths, avoid repeated removeFirst() on arrays (O(n)); use indices or popLast() where order permits. Algorithms to Remember zip to iterate pairs; stride(from:to:by:) for steps; prefix/while, drop/while for stream-like processing. grouping via Dictionary(grouping:by:); chunks manually via stride or rolling indices. Testing Add property-based checks (if available) for algorithms to ensure invariants (e.g., sorted output length matches input). Benchmark critical paths with measure in XCTest or simple timing helpers; ensure lazy vs eager choices are intentional. "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Collections and Algorithms (with version cues)
Sequence vs Collection, common transforms, and performance considerations.
Version Quick Reference

Swift 5.x+: standard library offers CoW collections, lazy views, and SIMD-backed ContiguousArray.
Swift 5.7+: improved type inference with primary associated types; any spelling required for existentials.
Swift 5.9+: parameter packs/variadic generics (advanced; not covered here).

Sequence vs Collection

Sequence: single-pass iteration guaranteed; may be destructive. Use when you don’t need indices or multiple passes.
Collection: multi-pass with stable indices (startIndex/endIndex). Prefer for in-memory data you traverse multiple times.

Common Transforms

map/compactMap/flatMap: convert, filter nils, flatten.
filter: keep matching elements; be mindful of allocation on large data.
reduce: combine into a single value; prefer reduce(into:) to avoid intermediate allocations.



1
2
3
4


let upper = names.map { $0.uppercased() }
let numbers = strings.compactMap(Int.init)
let flattened = [[1,2],[3]].flatMap { $0 }
let counts = words.reduce(into: [:]) { $0[$1, default: 0] += 1 }


Lazy Views

Use .lazy to defer work and reduce intermediate allocations, especially after filters and maps chained together.



1


let firstBig = numbers.lazy.filter { $0 > 1000 }.first


Slicing and Subsequence

Slices (ArraySlice, Substring) share storage with the base collection; copy to Array/String if you need long-term storage.



1
2


let slice = array[2...]      // ArraySlice
let copy = Array(slice)      // makes an owned copy


Sorting and Searching

sorted() returns a new array; sort() mutates in-place (more memory efficient).
For membership checks on large datasets, consider Set or Dictionary over linear contains.

Mutations and Performance

Prefer reserveCapacity on arrays and dictionaries when size is known to reduce reallocations.
For hot paths, avoid repeated removeFirst() on arrays (O(n)); use indices or popLast() where order permits.

Algorithms to Remember

zip to iterate pairs; stride(from:to:by:) for steps; prefix/while, drop/while for stream-like processing.
grouping via Dictionary(grouping:by:); chunks manually via stride or rolling indices.

Testing

Add property-based checks (if available) for algorithms to ensure invariants (e.g., sorted output length matches input).
Benchmark critical paths with measure in XCTest or simple timing helpers; ensure lazy vs eager choices are intentional.
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://sametkoyuncu.github.io/swift-notes/notes/"},{"@type":"ListItem","position":2,"name":"","item":"https://sametkoyuncu.github.io/swift-notes/notes/items/collections-and-algorithms/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Collections and Algorithms (with version cues) Sequence vs Collection, common transforms, and performance considerations.\nVersion Quick Reference Swift 5.x+: standard library offers CoW collections, lazy views, and SIMD-backed ContiguousArray. Swift 5.7+: improved type inference with primary associated types; any spelling required for existentials. Swift 5.9+: parameter packs/variadic generics (advanced; not covered here). Sequence vs Collection Sequence: single-pass iteration guaranteed; may be destructive. Use when you don’t need indices or multiple passes. Collection: multi-pass with stable indices (startIndex/endIndex). Prefer for in-memory data you traverse multiple times. Common Transforms map/compactMap/flatMap: convert, filter nils, flatten. filter: keep matching elements; be mindful of allocation on large data. reduce: combine into a single value; prefer reduce(into:) to avoid intermediate allocations. 1 2 3 4 let upper = names.map { $0.uppercased() } let numbers = strings.compactMap(Int.init) let flattened = [[1,2],[3]].flatMap { $0 } let counts = words.reduce(into: [:]) { $0[$1, default: 0] += 1 } Lazy Views Use .lazy to defer work and reduce intermediate allocations, especially after filters and maps chained together. 1 let firstBig = numbers.lazy.filter { $0 \u0026gt; 1000 }.first Slicing and Subsequence Slices (ArraySlice, Substring) share storage with the base collection; copy to Array/String if you need long-term storage. 1 2 let slice = array[2...] // ArraySlice let copy = Array(slice) // makes an owned copy Sorting and Searching sorted() returns a new array; sort() mutates in-place (more memory efficient). For membership checks on large datasets, consider Set or Dictionary over linear contains. Mutations and Performance Prefer reserveCapacity on arrays and dictionaries when size is known to reduce reallocations. For hot paths, avoid repeated removeFirst() on arrays (O(n)); use indices or popLast() where order permits. Algorithms to Remember zip to iterate pairs; stride(from:to:by:) for steps; prefix/while, drop/while for stream-like processing. grouping via Dictionary(grouping:by:); chunks manually via stride or rolling indices. Testing Add property-based checks (if available) for algorithms to ensure invariants (e.g., sorted output length matches input). Benchmark critical paths with measure in XCTest or simple timing helpers; ensure lazy vs eager choices are intentional. ","keywords":[],"articleBody":"Collections and Algorithms (with version cues) Sequence vs Collection, common transforms, and performance considerations.\nVersion Quick Reference Swift 5.x+: standard library offers CoW collections, lazy views, and SIMD-backed ContiguousArray. Swift 5.7+: improved type inference with primary associated types; any spelling required for existentials. Swift 5.9+: parameter packs/variadic generics (advanced; not covered here). Sequence vs Collection Sequence: single-pass iteration guaranteed; may be destructive. Use when you don’t need indices or multiple passes. Collection: multi-pass with stable indices (startIndex/endIndex). Prefer for in-memory data you traverse multiple times. Common Transforms map/compactMap/flatMap: convert, filter nils, flatten. filter: keep matching elements; be mindful of allocation on large data. reduce: combine into a single value; prefer reduce(into:) to avoid intermediate allocations. 1 2 3 4 let upper = names.map { $0.uppercased() } let numbers = strings.compactMap(Int.init) let flattened = [[1,2],[3]].flatMap { $0 } let counts = words.reduce(into: [:]) { $0[$1, default: 0] += 1 } Lazy Views Use .lazy to defer work and reduce intermediate allocations, especially after filters and maps chained together. 1 let firstBig = numbers.lazy.filter { $0 \u003e 1000 }.first Slicing and Subsequence Slices (ArraySlice, Substring) share storage with the base collection; copy to Array/String if you need long-term storage. 1 2 let slice = array[2...] // ArraySlice let copy = Array(slice) // makes an owned copy Sorting and Searching sorted() returns a new array; sort() mutates in-place (more memory efficient). For membership checks on large datasets, consider Set or Dictionary over linear contains. Mutations and Performance Prefer reserveCapacity on arrays and dictionaries when size is known to reduce reallocations. For hot paths, avoid repeated removeFirst() on arrays (O(n)); use indices or popLast() where order permits. Algorithms to Remember zip to iterate pairs; stride(from:to:by:) for steps; prefix/while, drop/while for stream-like processing. grouping via Dictionary(grouping:by:); chunks manually via stride or rolling indices. Testing Add property-based checks (if available) for algorithms to ensure invariants (e.g., sorted output length matches input). Benchmark critical paths with measure in XCTest or simple timing helpers; ensure lazy vs eager choices are intentional. ","wordCount":"333","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sametkoyuncu.github.io/swift-notes/notes/items/collections-and-algorithms/"},"publisher":{"@type":"Organization","name":"Swift Notes","logo":{"@type":"ImageObject","url":"https://sametkoyuncu.github.io/swift-notes/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://sametkoyuncu.github.io/swift-notes/ accesskey=h title="Swift Notes (Alt + H)">Swift Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sametkoyuncu.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://sametkoyuncu.github.io/cheat-sheets/ title="Cheat Sheets"><span>Cheat Sheets</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sametkoyuncu.github.io/swift-notes/>Home</a>&nbsp;»&nbsp;<a href=https://sametkoyuncu.github.io/swift-notes/notes/>Notes</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta><span>2 min</span></div></header><div class=post-content><h1 id=collections-and-algorithms-with-version-cues>Collections and Algorithms (with version cues)<a hidden class=anchor aria-hidden=true href=#collections-and-algorithms-with-version-cues>#</a></h1><p>Sequence vs Collection, common transforms, and performance considerations.</p><h2 id=version-quick-reference>Version Quick Reference<a hidden class=anchor aria-hidden=true href=#version-quick-reference>#</a></h2><ul><li>Swift 5.x+: standard library offers CoW collections, lazy views, and SIMD-backed <code>ContiguousArray</code>.</li><li>Swift 5.7+: improved type inference with primary associated types; <code>any</code> spelling required for existentials.</li><li>Swift 5.9+: parameter packs/variadic generics (advanced; not covered here).</li></ul><h2 id=sequence-vs-collection>Sequence vs Collection<a hidden class=anchor aria-hidden=true href=#sequence-vs-collection>#</a></h2><ul><li><code>Sequence</code>: single-pass iteration guaranteed; may be destructive. Use when you don’t need indices or multiple passes.</li><li><code>Collection</code>: multi-pass with stable indices (<code>startIndex</code>/<code>endIndex</code>). Prefer for in-memory data you traverse multiple times.</li></ul><h2 id=common-transforms>Common Transforms<a hidden class=anchor aria-hidden=true href=#common-transforms>#</a></h2><ul><li><code>map/compactMap/flatMap</code>: convert, filter nils, flatten.</li><li><code>filter</code>: keep matching elements; be mindful of allocation on large data.</li><li><code>reduce</code>: combine into a single value; prefer <code>reduce(into:)</code> to avoid intermediate allocations.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>upper</span> <span class=p>=</span> <span class=n>names</span><span class=p>.</span><span class=bp>map</span> <span class=p>{</span> <span class=nv>$0</span><span class=p>.</span><span class=n>uppercased</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>numbers</span> <span class=p>=</span> <span class=n>strings</span><span class=p>.</span><span class=n>compactMap</span><span class=p>(</span><span class=nb>Int</span><span class=p>.</span><span class=kd>init</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>flattened</span> <span class=p>=</span> <span class=p>[[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>],[</span><span class=mi>3</span><span class=p>]].</span><span class=n>flatMap</span> <span class=p>{</span> <span class=nv>$0</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>counts</span> <span class=p>=</span> <span class=n>words</span><span class=p>.</span><span class=bp>reduce</span><span class=p>(</span><span class=n>into</span><span class=p>:</span> <span class=p>[:])</span> <span class=p>{</span> <span class=nv>$0</span><span class=p>[</span><span class=nv>$1</span><span class=p>,</span> <span class=k>default</span><span class=p>:</span> <span class=mi>0</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=lazy-views>Lazy Views<a hidden class=anchor aria-hidden=true href=#lazy-views>#</a></h2><ul><li>Use <code>.lazy</code> to defer work and reduce intermediate allocations, especially after filters and maps chained together.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>firstBig</span> <span class=p>=</span> <span class=n>numbers</span><span class=p>.</span><span class=kr>lazy</span><span class=p>.</span><span class=bp>filter</span> <span class=p>{</span> <span class=nv>$0</span> <span class=o>&gt;</span> <span class=mi>1000</span> <span class=p>}.</span><span class=bp>first</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=slicing-and-subsequence>Slicing and Subsequence<a hidden class=anchor aria-hidden=true href=#slicing-and-subsequence>#</a></h2><ul><li>Slices (<code>ArraySlice</code>, <code>Substring</code>) share storage with the base collection; copy to <code>Array</code>/<code>String</code> if you need long-term storage.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>slice</span> <span class=p>=</span> <span class=n>array</span><span class=p>[</span><span class=mf>2.</span><span class=p>..]</span>      <span class=c1>// ArraySlice</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>copy</span> <span class=p>=</span> <span class=nb>Array</span><span class=p>(</span><span class=n>slice</span><span class=p>)</span>      <span class=c1>// makes an owned copy</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=sorting-and-searching>Sorting and Searching<a hidden class=anchor aria-hidden=true href=#sorting-and-searching>#</a></h2><ul><li><code>sorted()</code> returns a new array; <code>sort()</code> mutates in-place (more memory efficient).</li><li>For membership checks on large datasets, consider <code>Set</code> or <code>Dictionary</code> over linear <code>contains</code>.</li></ul><h2 id=mutations-and-performance>Mutations and Performance<a hidden class=anchor aria-hidden=true href=#mutations-and-performance>#</a></h2><ul><li>Prefer <code>reserveCapacity</code> on arrays and dictionaries when size is known to reduce reallocations.</li><li>For hot paths, avoid repeated <code>removeFirst()</code> on arrays (O(n)); use indices or <code>popLast()</code> where order permits.</li></ul><h2 id=algorithms-to-remember>Algorithms to Remember<a hidden class=anchor aria-hidden=true href=#algorithms-to-remember>#</a></h2><ul><li><code>zip</code> to iterate pairs; <code>stride(from:to:by:)</code> for steps; <code>prefix/while</code>, <code>drop/while</code> for stream-like processing.</li><li><code>grouping</code> via <code>Dictionary(grouping:by:)</code>; <code>chunks</code> manually via stride or rolling indices.</li></ul><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><ul><li>Add property-based checks (if available) for algorithms to ensure invariants (e.g., sorted output length matches input).</li><li>Benchmark critical paths with <code>measure</code> in XCTest or simple timing helpers; ensure lazy vs eager choices are intentional.</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://sametkoyuncu.github.io/swift-notes/notes/items/associated-types/><span class=title>« Prev</span><br><span></span>
</a><a class=next href=https://sametkoyuncu.github.io/swift-notes/notes/items/combine-and-asyncsequence/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sametkoyuncu.github.io/swift-notes/>Swift Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>