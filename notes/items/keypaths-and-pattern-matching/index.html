<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Swift Notes</title>
<meta name=keywords content><meta name=description content='KeyPaths and Pattern Matching (with version cues)
How to leverage key paths and pattern matching to write concise, readable Swift.
Version Quick Reference

Swift 4+: writable key paths, \.property syntax.
Swift 5.x+: KeyPath improvements and pattern matching ergonomics.
Swift 5.7+: any spelling for existentials can appear with KeyPath constraints.

KeyPath Basics

Use \Type.property to reference properties without calling them. Great for mapping, sorting, and dependency injection.



1
2
3
4


struct User { let name: String; let age: Int }

let names = users.map(\.name)
let sorted = users.sorted(by: \.age) // via overload taking a key path



For mutation, use WritableKeyPath and ReferenceWritableKeyPath (classes).



1
2
3


func set<Value>(_ keyPath: WritableKeyPath<User, Value>, to value: Value, on user: inout User) {
    user[keyPath: keyPath] = value
}


Dynamic Member Lookup

Some types expose dynamic members that forward through key paths (e.g., SwiftUI.Binding). You can build your own with @dynamicMemberLookup and subscript overloads taking key paths.

Pattern Matching Essentials

switch supports case, where clauses, and pattern bindings for enums, optionals, tuples, ranges, and custom patterns.



1
2
3
4
5
6
7
8


switch value {
case .success(let data):
    handle(data)
case .failure(let error) where error.isRetriable:
    retry()
case .failure:
    break
}


if case / guard case

Use to destructure single values without a full switch.



1
2
3
4


if case .failure(let error) = result { print(error) }

guard case .success(let payload) = result else { return }
process(payload)


Optional Patterns

Match .some/.none or use if case let x?.



1


if case let value? = optionalValue { print(value) }


Tuple and Range Patterns

Destructure tuples in switches; match numeric ranges with ... or ..<.



1
2
3
4
5
6


let point = (x: 3, y: 7)
switch point {
case (0, 0): print("origin")
case (1..., 1...): print("quadrant")
default: break
}


Custom Pattern Matching

Implement ~= (pattern:value:) to enable custom matching. Keep it lightweight and predictable.



1
2
3
4
5
6
7


struct Prefix { let value: String }
func ~=(pattern: Prefix, value: String) -> Bool { value.hasPrefix(pattern.value) }

switch "swift-notes" {
case Prefix("swift"): print("matches")
default: break
}


Tips

Prefer exhaustive switch on enums to catch new cases at compile time.
Combine where clauses for readability instead of nesting conditionals.
Keep custom patterns simple to avoid surprising control flow.
'><meta name=author content><link rel=canonical href=https://sametkoyuncu.github.io/swift-notes/notes/items/keypaths-and-pattern-matching/><link crossorigin=anonymous href=../../../swift-notes/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://sametkoyuncu.github.io/swift-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sametkoyuncu.github.io/swift-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sametkoyuncu.github.io/swift-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://sametkoyuncu.github.io/swift-notes/apple-touch-icon.png><link rel=mask-icon href=https://sametkoyuncu.github.io/swift-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sametkoyuncu.github.io/swift-notes/notes/items/keypaths-and-pattern-matching/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://sametkoyuncu.github.io/swift-notes/notes/items/keypaths-and-pattern-matching/"><meta property="og:site_name" content="Swift Notes"><meta property="og:title" content="Swift Notes"><meta property="og:description" content='KeyPaths and Pattern Matching (with version cues) How to leverage key paths and pattern matching to write concise, readable Swift.
Version Quick Reference Swift 4+: writable key paths, \.property syntax. Swift 5.x+: KeyPath improvements and pattern matching ergonomics. Swift 5.7+: any spelling for existentials can appear with KeyPath constraints. KeyPath Basics Use \Type.property to reference properties without calling them. Great for mapping, sorting, and dependency injection. 1 2 3 4 struct User { let name: String; let age: Int } let names = users.map(\.name) let sorted = users.sorted(by: \.age) // via overload taking a key path For mutation, use WritableKeyPath and ReferenceWritableKeyPath (classes). 1 2 3 func set<Value>(_ keyPath: WritableKeyPath<User, Value>, to value: Value, on user: inout User) { user[keyPath: keyPath] = value } Dynamic Member Lookup Some types expose dynamic members that forward through key paths (e.g., SwiftUI.Binding). You can build your own with @dynamicMemberLookup and subscript overloads taking key paths. Pattern Matching Essentials switch supports case, where clauses, and pattern bindings for enums, optionals, tuples, ranges, and custom patterns. 1 2 3 4 5 6 7 8 switch value { case .success(let data): handle(data) case .failure(let error) where error.isRetriable: retry() case .failure: break } if case / guard case Use to destructure single values without a full switch. 1 2 3 4 if case .failure(let error) = result { print(error) } guard case .success(let payload) = result else { return } process(payload) Optional Patterns Match .some/.none or use if case let x?. 1 if case let value? = optionalValue { print(value) } Tuple and Range Patterns Destructure tuples in switches; match numeric ranges with ... or ..<. 1 2 3 4 5 6 let point = (x: 3, y: 7) switch point { case (0, 0): print("origin") case (1..., 1...): print("quadrant") default: break } Custom Pattern Matching Implement ~= (pattern:value:) to enable custom matching. Keep it lightweight and predictable. 1 2 3 4 5 6 7 struct Prefix { let value: String } func ~=(pattern: Prefix, value: String) -> Bool { value.hasPrefix(pattern.value) } switch "swift-notes" { case Prefix("swift"): print("matches") default: break } Tips Prefer exhaustive switch on enums to catch new cases at compile time. Combine where clauses for readability instead of nesting conditionals. Keep custom patterns simple to avoid surprising control flow. '><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content='KeyPaths and Pattern Matching (with version cues)
How to leverage key paths and pattern matching to write concise, readable Swift.
Version Quick Reference

Swift 4+: writable key paths, \.property syntax.
Swift 5.x+: KeyPath improvements and pattern matching ergonomics.
Swift 5.7+: any spelling for existentials can appear with KeyPath constraints.

KeyPath Basics

Use \Type.property to reference properties without calling them. Great for mapping, sorting, and dependency injection.



1
2
3
4


struct User { let name: String; let age: Int }

let names = users.map(\.name)
let sorted = users.sorted(by: \.age) // via overload taking a key path



For mutation, use WritableKeyPath and ReferenceWritableKeyPath (classes).



1
2
3


func set<Value>(_ keyPath: WritableKeyPath<User, Value>, to value: Value, on user: inout User) {
    user[keyPath: keyPath] = value
}


Dynamic Member Lookup

Some types expose dynamic members that forward through key paths (e.g., SwiftUI.Binding). You can build your own with @dynamicMemberLookup and subscript overloads taking key paths.

Pattern Matching Essentials

switch supports case, where clauses, and pattern bindings for enums, optionals, tuples, ranges, and custom patterns.



1
2
3
4
5
6
7
8


switch value {
case .success(let data):
    handle(data)
case .failure(let error) where error.isRetriable:
    retry()
case .failure:
    break
}


if case / guard case

Use to destructure single values without a full switch.



1
2
3
4


if case .failure(let error) = result { print(error) }

guard case .success(let payload) = result else { return }
process(payload)


Optional Patterns

Match .some/.none or use if case let x?.



1


if case let value? = optionalValue { print(value) }


Tuple and Range Patterns

Destructure tuples in switches; match numeric ranges with ... or ..<.



1
2
3
4
5
6


let point = (x: 3, y: 7)
switch point {
case (0, 0): print("origin")
case (1..., 1...): print("quadrant")
default: break
}


Custom Pattern Matching

Implement ~= (pattern:value:) to enable custom matching. Keep it lightweight and predictable.



1
2
3
4
5
6
7


struct Prefix { let value: String }
func ~=(pattern: Prefix, value: String) -> Bool { value.hasPrefix(pattern.value) }

switch "swift-notes" {
case Prefix("swift"): print("matches")
default: break
}


Tips

Prefer exhaustive switch on enums to catch new cases at compile time.
Combine where clauses for readability instead of nesting conditionals.
Keep custom patterns simple to avoid surprising control flow.
'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://sametkoyuncu.github.io/swift-notes/notes/"},{"@type":"ListItem","position":2,"name":"","item":"https://sametkoyuncu.github.io/swift-notes/notes/items/keypaths-and-pattern-matching/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"KeyPaths and Pattern Matching (with version cues) How to leverage key paths and pattern matching to write concise, readable Swift.\nVersion Quick Reference Swift 4+: writable key paths, \\.property syntax. Swift 5.x+: KeyPath improvements and pattern matching ergonomics. Swift 5.7+: any spelling for existentials can appear with KeyPath constraints. KeyPath Basics Use \\Type.property to reference properties without calling them. Great for mapping, sorting, and dependency injection. 1 2 3 4 struct User { let name: String; let age: Int } let names = users.map(\\.name) let sorted = users.sorted(by: \\.age) // via overload taking a key path For mutation, use WritableKeyPath and ReferenceWritableKeyPath (classes). 1 2 3 func set\u0026lt;Value\u0026gt;(_ keyPath: WritableKeyPath\u0026lt;User, Value\u0026gt;, to value: Value, on user: inout User) { user[keyPath: keyPath] = value } Dynamic Member Lookup Some types expose dynamic members that forward through key paths (e.g., SwiftUI.Binding). You can build your own with @dynamicMemberLookup and subscript overloads taking key paths. Pattern Matching Essentials switch supports case, where clauses, and pattern bindings for enums, optionals, tuples, ranges, and custom patterns. 1 2 3 4 5 6 7 8 switch value { case .success(let data): handle(data) case .failure(let error) where error.isRetriable: retry() case .failure: break } if case / guard case Use to destructure single values without a full switch. 1 2 3 4 if case .failure(let error) = result { print(error) } guard case .success(let payload) = result else { return } process(payload) Optional Patterns Match .some/.none or use if case let x?. 1 if case let value? = optionalValue { print(value) } Tuple and Range Patterns Destructure tuples in switches; match numeric ranges with ... or ..\u0026lt;. 1 2 3 4 5 6 let point = (x: 3, y: 7) switch point { case (0, 0): print(\u0026#34;origin\u0026#34;) case (1..., 1...): print(\u0026#34;quadrant\u0026#34;) default: break } Custom Pattern Matching Implement ~= (pattern:value:) to enable custom matching. Keep it lightweight and predictable. 1 2 3 4 5 6 7 struct Prefix { let value: String } func ~=(pattern: Prefix, value: String) -\u0026gt; Bool { value.hasPrefix(pattern.value) } switch \u0026#34;swift-notes\u0026#34; { case Prefix(\u0026#34;swift\u0026#34;): print(\u0026#34;matches\u0026#34;) default: break } Tips Prefer exhaustive switch on enums to catch new cases at compile time. Combine where clauses for readability instead of nesting conditionals. Keep custom patterns simple to avoid surprising control flow. ","keywords":[],"articleBody":"KeyPaths and Pattern Matching (with version cues) How to leverage key paths and pattern matching to write concise, readable Swift.\nVersion Quick Reference Swift 4+: writable key paths, \\.property syntax. Swift 5.x+: KeyPath improvements and pattern matching ergonomics. Swift 5.7+: any spelling for existentials can appear with KeyPath constraints. KeyPath Basics Use \\Type.property to reference properties without calling them. Great for mapping, sorting, and dependency injection. 1 2 3 4 struct User { let name: String; let age: Int } let names = users.map(\\.name) let sorted = users.sorted(by: \\.age) // via overload taking a key path For mutation, use WritableKeyPath and ReferenceWritableKeyPath (classes). 1 2 3 func set\u003cValue\u003e(_ keyPath: WritableKeyPath\u003cUser, Value\u003e, to value: Value, on user: inout User) { user[keyPath: keyPath] = value } Dynamic Member Lookup Some types expose dynamic members that forward through key paths (e.g., SwiftUI.Binding). You can build your own with @dynamicMemberLookup and subscript overloads taking key paths. Pattern Matching Essentials switch supports case, where clauses, and pattern bindings for enums, optionals, tuples, ranges, and custom patterns. 1 2 3 4 5 6 7 8 switch value { case .success(let data): handle(data) case .failure(let error) where error.isRetriable: retry() case .failure: break } if case / guard case Use to destructure single values without a full switch. 1 2 3 4 if case .failure(let error) = result { print(error) } guard case .success(let payload) = result else { return } process(payload) Optional Patterns Match .some/.none or use if case let x?. 1 if case let value? = optionalValue { print(value) } Tuple and Range Patterns Destructure tuples in switches; match numeric ranges with ... or ..\u003c. 1 2 3 4 5 6 let point = (x: 3, y: 7) switch point { case (0, 0): print(\"origin\") case (1..., 1...): print(\"quadrant\") default: break } Custom Pattern Matching Implement ~= (pattern:value:) to enable custom matching. Keep it lightweight and predictable. 1 2 3 4 5 6 7 struct Prefix { let value: String } func ~=(pattern: Prefix, value: String) -\u003e Bool { value.hasPrefix(pattern.value) } switch \"swift-notes\" { case Prefix(\"swift\"): print(\"matches\") default: break } Tips Prefer exhaustive switch on enums to catch new cases at compile time. Combine where clauses for readability instead of nesting conditionals. Keep custom patterns simple to avoid surprising control flow. ","wordCount":"375","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sametkoyuncu.github.io/swift-notes/notes/items/keypaths-and-pattern-matching/"},"publisher":{"@type":"Organization","name":"Swift Notes","logo":{"@type":"ImageObject","url":"https://sametkoyuncu.github.io/swift-notes/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://sametkoyuncu.github.io/swift-notes/ accesskey=h title="Swift Notes (Alt + H)">Swift Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sametkoyuncu.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://sametkoyuncu.github.io/cheat-sheets/ title="Cheat Sheets"><span>Cheat Sheets</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sametkoyuncu.github.io/swift-notes/>Home</a>&nbsp;»&nbsp;<a href=https://sametkoyuncu.github.io/swift-notes/notes/>Notes</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta><span>2 min</span></div></header><div class=post-content><h1 id=keypaths-and-pattern-matching-with-version-cues>KeyPaths and Pattern Matching (with version cues)<a hidden class=anchor aria-hidden=true href=#keypaths-and-pattern-matching-with-version-cues>#</a></h1><p>How to leverage key paths and pattern matching to write concise, readable Swift.</p><h2 id=version-quick-reference>Version Quick Reference<a hidden class=anchor aria-hidden=true href=#version-quick-reference>#</a></h2><ul><li>Swift 4+: writable key paths, <code>\.property</code> syntax.</li><li>Swift 5.x+: <code>KeyPath</code> improvements and pattern matching ergonomics.</li><li>Swift 5.7+: <code>any</code> spelling for existentials can appear with <code>KeyPath</code> constraints.</li></ul><h2 id=keypath-basics>KeyPath Basics<a hidden class=anchor aria-hidden=true href=#keypath-basics>#</a></h2><ul><li>Use <code>\Type.property</code> to reference properties without calling them. Great for mapping, sorting, and dependency injection.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>User</span> <span class=p>{</span> <span class=kd>let</span> <span class=nv>name</span><span class=p>:</span> <span class=nb>String</span><span class=p>;</span> <span class=kd>let</span> <span class=nv>age</span><span class=p>:</span> <span class=nb>Int</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>names</span> <span class=p>=</span> <span class=n>users</span><span class=p>.</span><span class=bp>map</span><span class=p>(</span><span class=err>\</span><span class=p>.</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>sorted</span> <span class=p>=</span> <span class=n>users</span><span class=p>.</span><span class=bp>sorted</span><span class=p>(</span><span class=n>by</span><span class=p>:</span> <span class=err>\</span><span class=p>.</span><span class=n>age</span><span class=p>)</span> <span class=c1>// via overload taking a key path</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>For mutation, use <code>WritableKeyPath</code> and <code>ReferenceWritableKeyPath</code> (classes).</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>set</span><span class=p>&lt;</span><span class=n>Value</span><span class=p>&gt;(</span><span class=kc>_</span> <span class=n>keyPath</span><span class=p>:</span> <span class=n>WritableKeyPath</span><span class=p>&lt;</span><span class=n>User</span><span class=p>,</span> <span class=n>Value</span><span class=p>&gt;,</span> <span class=n>to</span> <span class=n>value</span><span class=p>:</span> <span class=n>Value</span><span class=p>,</span> <span class=n>on</span> <span class=n>user</span><span class=p>:</span> <span class=kr>inout</span> <span class=n>User</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>user</span><span class=p>[</span><span class=n>keyPath</span><span class=p>:</span> <span class=n>keyPath</span><span class=p>]</span> <span class=p>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=dynamic-member-lookup>Dynamic Member Lookup<a hidden class=anchor aria-hidden=true href=#dynamic-member-lookup>#</a></h2><ul><li>Some types expose dynamic members that forward through key paths (e.g., <code>SwiftUI.Binding</code>). You can build your own with <code>@dynamicMemberLookup</code> and subscript overloads taking key paths.</li></ul><h2 id=pattern-matching-essentials>Pattern Matching Essentials<a hidden class=anchor aria-hidden=true href=#pattern-matching-essentials>#</a></h2><ul><li><code>switch</code> supports <code>case</code>, <code>where</code> clauses, and pattern bindings for enums, optionals, tuples, ranges, and custom patterns.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=k>switch</span> <span class=n>value</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=p>.</span><span class=n>success</span><span class=p>(</span><span class=kd>let</span> <span class=nv>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>handle</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=p>.</span><span class=n>failure</span><span class=p>(</span><span class=kd>let</span> <span class=nv>error</span><span class=p>)</span> <span class=k>where</span> <span class=n>error</span><span class=p>.</span><span class=n>isRetriable</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>retry</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=p>.</span><span class=n>failure</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=if-case--guard-case><code>if case</code> / <code>guard case</code><a hidden class=anchor aria-hidden=true href=#if-case--guard-case>#</a></h2><ul><li>Use to destructure single values without a full <code>switch</code>.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=k>if</span> <span class=k>case</span> <span class=p>.</span><span class=n>failure</span><span class=p>(</span><span class=kd>let</span> <span class=nv>error</span><span class=p>)</span> <span class=p>=</span> <span class=n>result</span> <span class=p>{</span> <span class=bp>print</span><span class=p>(</span><span class=n>error</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>guard</span> <span class=k>case</span> <span class=p>.</span><span class=n>success</span><span class=p>(</span><span class=kd>let</span> <span class=nv>payload</span><span class=p>)</span> <span class=p>=</span> <span class=n>result</span> <span class=k>else</span> <span class=p>{</span> <span class=k>return</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>process</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=optional-patterns>Optional Patterns<a hidden class=anchor aria-hidden=true href=#optional-patterns>#</a></h2><ul><li>Match <code>.some</code>/<code>.none</code> or use <code>if case let x?</code>.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=k>if</span> <span class=k>case</span> <span class=kd>let</span> <span class=nv>value</span><span class=p>?</span> <span class=p>=</span> <span class=n>optionalValue</span> <span class=p>{</span> <span class=bp>print</span><span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=tuple-and-range-patterns>Tuple and Range Patterns<a hidden class=anchor aria-hidden=true href=#tuple-and-range-patterns>#</a></h2><ul><li>Destructure tuples in switches; match numeric ranges with <code>...</code> or <code>..&lt;</code>.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>point</span> <span class=p>=</span> <span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=n>point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>):</span> <span class=bp>print</span><span class=p>(</span><span class=s>&#34;origin&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=p>(</span><span class=mf>1.</span><span class=p>..,</span> <span class=mf>1.</span><span class=p>..):</span> <span class=bp>print</span><span class=p>(</span><span class=s>&#34;quadrant&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=p>:</span> <span class=k>break</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=custom-pattern-matching>Custom Pattern Matching<a hidden class=anchor aria-hidden=true href=#custom-pattern-matching>#</a></h2><ul><li>Implement <code>~= (pattern:value:)</code> to enable custom matching. Keep it lightweight and predictable.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Prefix</span> <span class=p>{</span> <span class=kd>let</span> <span class=nv>value</span><span class=p>:</span> <span class=nb>String</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=o>~=</span><span class=p>(</span><span class=n>pattern</span><span class=p>:</span> <span class=n>Prefix</span><span class=p>,</span> <span class=n>value</span><span class=p>:</span> <span class=nb>String</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nb>Bool</span> <span class=p>{</span> <span class=n>value</span><span class=p>.</span><span class=n>hasPrefix</span><span class=p>(</span><span class=n>pattern</span><span class=p>.</span><span class=n>value</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=s>&#34;swift-notes&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=n>Prefix</span><span class=p>(</span><span class=s>&#34;swift&#34;</span><span class=p>):</span> <span class=bp>print</span><span class=p>(</span><span class=s>&#34;matches&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=p>:</span> <span class=k>break</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=tips>Tips<a hidden class=anchor aria-hidden=true href=#tips>#</a></h2><ul><li>Prefer exhaustive <code>switch</code> on enums to catch new cases at compile time.</li><li>Combine <code>where</code> clauses for readability instead of nesting conditionals.</li><li>Keep custom patterns simple to avoid surprising control flow.</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://sametkoyuncu.github.io/swift-notes/notes/items/generics-and-constraints/><span class=title>« Prev</span><br><span></span>
</a><a class=next href=https://sametkoyuncu.github.io/swift-notes/notes/items/memory-and-semantics/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sametkoyuncu.github.io/swift-notes/>Swift Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>