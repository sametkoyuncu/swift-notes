<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Swift Notes</title>
<meta name=keywords content><meta name=description content='SwiftUI Navigation (with version cues)
Choosing NavigationStack/NavigationPath vs NavigationLink, deep links, and state handling.
Version Quick Reference

iOS 13: NavigationView + NavigationLink (static destinations).
iOS 16: NavigationStack, NavigationPath, NavigationSplitView, programmatic navigation, typed destinations.
iOS 17: refinements to navigation APIs; observation macro (@Observable) can simplify state models if available.

NavigationStack + NavigationPath (iOS 16+)

Prefer NavigationStack for push-style flows; store a NavigationPath in @State to support deep links and programmatic pops.



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


struct ScreenA: Hashable { let id = UUID() }
struct ScreenB: Hashable { let id = UUID() }

struct RootView: View {
    @State private var path = NavigationPath()

    var body: some View {
        NavigationStack(path: $path) {
            List {
                Button("Go to B") { path.append(ScreenB()) }
            }
            .navigationDestination(for: ScreenB.self) { _ in
                ScreenBView(onClose: { path.removeLast() })
            }
        }
    }
}



Use value types that conform to Hashable for path elements; keep them small (IDs, not full models).

NavigationLink (static destinations)

For simple lists of known destinations, NavigationLink(destination:) is fine. Avoid mixing old NavigationView with new stack APIs in the same flow.

Deep Links

Translate URLs/intents into path elements. Initialize @State var path from the parsed deep link so navigation reflects the initial route.
Handle unknown routes gracefully by clearing or showing a fallback screen.

Programmatic Pops

path.removeLast() pops one; path.removeLast(path.count) pops to root. Guard against empty paths to avoid runtime errors.

Split View (iPad / macOS) (iOS 16+)

Use NavigationSplitView for master-detail; keep selection in @State or @Binding and use navigationDestination for detail stacks.

State Management Tips

Keep navigation state separate from data state. Use small enums/IDs to represent routes; store data elsewhere (view models, environment).
Avoid storing full models in NavigationPath; use identifiers and fetch as needed to reduce serialization costs and data duplication.

Testing and Previews

For previews, seed path with sample routes to verify deep links.
For UI tests, assert navigation by checking existence of destination views and path counts if exposed through accessibility.
'><meta name=author content><link rel=canonical href=https://sametkoyuncu.github.io/swift-notes/notes/items/swiftui-navigation/><link crossorigin=anonymous href=../../../swift-notes/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://sametkoyuncu.github.io/swift-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sametkoyuncu.github.io/swift-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sametkoyuncu.github.io/swift-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://sametkoyuncu.github.io/swift-notes/apple-touch-icon.png><link rel=mask-icon href=https://sametkoyuncu.github.io/swift-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sametkoyuncu.github.io/swift-notes/notes/items/swiftui-navigation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://sametkoyuncu.github.io/swift-notes/notes/items/swiftui-navigation/"><meta property="og:site_name" content="Swift Notes"><meta property="og:title" content="Swift Notes"><meta property="og:description" content='SwiftUI Navigation (with version cues) Choosing NavigationStack/NavigationPath vs NavigationLink, deep links, and state handling.
Version Quick Reference iOS 13: NavigationView + NavigationLink (static destinations). iOS 16: NavigationStack, NavigationPath, NavigationSplitView, programmatic navigation, typed destinations. iOS 17: refinements to navigation APIs; observation macro (@Observable) can simplify state models if available. NavigationStack + NavigationPath (iOS 16+) Prefer NavigationStack for push-style flows; store a NavigationPath in @State to support deep links and programmatic pops. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct ScreenA: Hashable { let id = UUID() } struct ScreenB: Hashable { let id = UUID() } struct RootView: View { @State private var path = NavigationPath() var body: some View { NavigationStack(path: $path) { List { Button("Go to B") { path.append(ScreenB()) } } .navigationDestination(for: ScreenB.self) { _ in ScreenBView(onClose: { path.removeLast() }) } } } } Use value types that conform to Hashable for path elements; keep them small (IDs, not full models). NavigationLink (static destinations) For simple lists of known destinations, NavigationLink(destination:) is fine. Avoid mixing old NavigationView with new stack APIs in the same flow. Deep Links Translate URLs/intents into path elements. Initialize @State var path from the parsed deep link so navigation reflects the initial route. Handle unknown routes gracefully by clearing or showing a fallback screen. Programmatic Pops path.removeLast() pops one; path.removeLast(path.count) pops to root. Guard against empty paths to avoid runtime errors. Split View (iPad / macOS) (iOS 16+) Use NavigationSplitView for master-detail; keep selection in @State or @Binding and use navigationDestination for detail stacks. State Management Tips Keep navigation state separate from data state. Use small enums/IDs to represent routes; store data elsewhere (view models, environment). Avoid storing full models in NavigationPath; use identifiers and fetch as needed to reduce serialization costs and data duplication. Testing and Previews For previews, seed path with sample routes to verify deep links. For UI tests, assert navigation by checking existence of destination views and path counts if exposed through accessibility. '><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content='SwiftUI Navigation (with version cues)
Choosing NavigationStack/NavigationPath vs NavigationLink, deep links, and state handling.
Version Quick Reference

iOS 13: NavigationView + NavigationLink (static destinations).
iOS 16: NavigationStack, NavigationPath, NavigationSplitView, programmatic navigation, typed destinations.
iOS 17: refinements to navigation APIs; observation macro (@Observable) can simplify state models if available.

NavigationStack + NavigationPath (iOS 16+)

Prefer NavigationStack for push-style flows; store a NavigationPath in @State to support deep links and programmatic pops.



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


struct ScreenA: Hashable { let id = UUID() }
struct ScreenB: Hashable { let id = UUID() }

struct RootView: View {
    @State private var path = NavigationPath()

    var body: some View {
        NavigationStack(path: $path) {
            List {
                Button("Go to B") { path.append(ScreenB()) }
            }
            .navigationDestination(for: ScreenB.self) { _ in
                ScreenBView(onClose: { path.removeLast() })
            }
        }
    }
}



Use value types that conform to Hashable for path elements; keep them small (IDs, not full models).

NavigationLink (static destinations)

For simple lists of known destinations, NavigationLink(destination:) is fine. Avoid mixing old NavigationView with new stack APIs in the same flow.

Deep Links

Translate URLs/intents into path elements. Initialize @State var path from the parsed deep link so navigation reflects the initial route.
Handle unknown routes gracefully by clearing or showing a fallback screen.

Programmatic Pops

path.removeLast() pops one; path.removeLast(path.count) pops to root. Guard against empty paths to avoid runtime errors.

Split View (iPad / macOS) (iOS 16+)

Use NavigationSplitView for master-detail; keep selection in @State or @Binding and use navigationDestination for detail stacks.

State Management Tips

Keep navigation state separate from data state. Use small enums/IDs to represent routes; store data elsewhere (view models, environment).
Avoid storing full models in NavigationPath; use identifiers and fetch as needed to reduce serialization costs and data duplication.

Testing and Previews

For previews, seed path with sample routes to verify deep links.
For UI tests, assert navigation by checking existence of destination views and path counts if exposed through accessibility.
'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://sametkoyuncu.github.io/swift-notes/notes/"},{"@type":"ListItem","position":2,"name":"","item":"https://sametkoyuncu.github.io/swift-notes/notes/items/swiftui-navigation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"SwiftUI Navigation (with version cues) Choosing NavigationStack/NavigationPath vs NavigationLink, deep links, and state handling.\nVersion Quick Reference iOS 13: NavigationView + NavigationLink (static destinations). iOS 16: NavigationStack, NavigationPath, NavigationSplitView, programmatic navigation, typed destinations. iOS 17: refinements to navigation APIs; observation macro (@Observable) can simplify state models if available. NavigationStack + NavigationPath (iOS 16+) Prefer NavigationStack for push-style flows; store a NavigationPath in @State to support deep links and programmatic pops. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct ScreenA: Hashable { let id = UUID() } struct ScreenB: Hashable { let id = UUID() } struct RootView: View { @State private var path = NavigationPath() var body: some View { NavigationStack(path: $path) { List { Button(\u0026#34;Go to B\u0026#34;) { path.append(ScreenB()) } } .navigationDestination(for: ScreenB.self) { _ in ScreenBView(onClose: { path.removeLast() }) } } } } Use value types that conform to Hashable for path elements; keep them small (IDs, not full models). NavigationLink (static destinations) For simple lists of known destinations, NavigationLink(destination:) is fine. Avoid mixing old NavigationView with new stack APIs in the same flow. Deep Links Translate URLs/intents into path elements. Initialize @State var path from the parsed deep link so navigation reflects the initial route. Handle unknown routes gracefully by clearing or showing a fallback screen. Programmatic Pops path.removeLast() pops one; path.removeLast(path.count) pops to root. Guard against empty paths to avoid runtime errors. Split View (iPad / macOS) (iOS 16+) Use NavigationSplitView for master-detail; keep selection in @State or @Binding and use navigationDestination for detail stacks. State Management Tips Keep navigation state separate from data state. Use small enums/IDs to represent routes; store data elsewhere (view models, environment). Avoid storing full models in NavigationPath; use identifiers and fetch as needed to reduce serialization costs and data duplication. Testing and Previews For previews, seed path with sample routes to verify deep links. For UI tests, assert navigation by checking existence of destination views and path counts if exposed through accessibility. ","keywords":[],"articleBody":"SwiftUI Navigation (with version cues) Choosing NavigationStack/NavigationPath vs NavigationLink, deep links, and state handling.\nVersion Quick Reference iOS 13: NavigationView + NavigationLink (static destinations). iOS 16: NavigationStack, NavigationPath, NavigationSplitView, programmatic navigation, typed destinations. iOS 17: refinements to navigation APIs; observation macro (@Observable) can simplify state models if available. NavigationStack + NavigationPath (iOS 16+) Prefer NavigationStack for push-style flows; store a NavigationPath in @State to support deep links and programmatic pops. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct ScreenA: Hashable { let id = UUID() } struct ScreenB: Hashable { let id = UUID() } struct RootView: View { @State private var path = NavigationPath() var body: some View { NavigationStack(path: $path) { List { Button(\"Go to B\") { path.append(ScreenB()) } } .navigationDestination(for: ScreenB.self) { _ in ScreenBView(onClose: { path.removeLast() }) } } } } Use value types that conform to Hashable for path elements; keep them small (IDs, not full models). NavigationLink (static destinations) For simple lists of known destinations, NavigationLink(destination:) is fine. Avoid mixing old NavigationView with new stack APIs in the same flow. Deep Links Translate URLs/intents into path elements. Initialize @State var path from the parsed deep link so navigation reflects the initial route. Handle unknown routes gracefully by clearing or showing a fallback screen. Programmatic Pops path.removeLast() pops one; path.removeLast(path.count) pops to root. Guard against empty paths to avoid runtime errors. Split View (iPad / macOS) (iOS 16+) Use NavigationSplitView for master-detail; keep selection in @State or @Binding and use navigationDestination for detail stacks. State Management Tips Keep navigation state separate from data state. Use small enums/IDs to represent routes; store data elsewhere (view models, environment). Avoid storing full models in NavigationPath; use identifiers and fetch as needed to reduce serialization costs and data duplication. Testing and Previews For previews, seed path with sample routes to verify deep links. For UI tests, assert navigation by checking existence of destination views and path counts if exposed through accessibility. ","wordCount":"332","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sametkoyuncu.github.io/swift-notes/notes/items/swiftui-navigation/"},"publisher":{"@type":"Organization","name":"Swift Notes","logo":{"@type":"ImageObject","url":"https://sametkoyuncu.github.io/swift-notes/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://sametkoyuncu.github.io/swift-notes/ accesskey=h title="Swift Notes (Alt + H)">Swift Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sametkoyuncu.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://sametkoyuncu.github.io/cheat-sheets/ title="Cheat Sheets"><span>Cheat Sheets</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sametkoyuncu.github.io/swift-notes/>Home</a>&nbsp;»&nbsp;<a href=https://sametkoyuncu.github.io/swift-notes/notes/>Notes</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta><span>2 min</span></div></header><div class=post-content><h1 id=swiftui-navigation-with-version-cues>SwiftUI Navigation (with version cues)<a hidden class=anchor aria-hidden=true href=#swiftui-navigation-with-version-cues>#</a></h1><p>Choosing NavigationStack/NavigationPath vs NavigationLink, deep links, and state handling.</p><h2 id=version-quick-reference>Version Quick Reference<a hidden class=anchor aria-hidden=true href=#version-quick-reference>#</a></h2><ul><li>iOS 13: <code>NavigationView</code> + <code>NavigationLink</code> (static destinations).</li><li>iOS 16: <code>NavigationStack</code>, <code>NavigationPath</code>, <code>NavigationSplitView</code>, programmatic navigation, typed destinations.</li><li>iOS 17: refinements to navigation APIs; observation macro (<code>@Observable</code>) can simplify state models if available.</li></ul><h2 id=navigationstack--navigationpath-ios-16>NavigationStack + NavigationPath (iOS 16+)<a hidden class=anchor aria-hidden=true href=#navigationstack--navigationpath-ios-16>#</a></h2><ul><li>Prefer <code>NavigationStack</code> for push-style flows; store a <code>NavigationPath</code> in <code>@State</code> to support deep links and programmatic pops.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>ScreenA</span><span class=p>:</span> <span class=nb>Hashable</span> <span class=p>{</span> <span class=kd>let</span> <span class=nv>id</span> <span class=p>=</span> <span class=n>UUID</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>ScreenB</span><span class=p>:</span> <span class=nb>Hashable</span> <span class=p>{</span> <span class=kd>let</span> <span class=nv>id</span> <span class=p>=</span> <span class=n>UUID</span><span class=p>()</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>RootView</span><span class=p>:</span> <span class=n>View</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>@</span><span class=n>State</span> <span class=kd>private</span> <span class=kd>var</span> <span class=nv>path</span> <span class=p>=</span> <span class=n>NavigationPath</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nv>body</span><span class=p>:</span> <span class=n>some</span> <span class=n>View</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>NavigationStack</span><span class=p>(</span><span class=n>path</span><span class=p>:</span> <span class=err>$</span><span class=n>path</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>List</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Button</span><span class=p>(</span><span class=s>&#34;Go to B&#34;</span><span class=p>)</span> <span class=p>{</span> <span class=n>path</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=n>ScreenB</span><span class=p>())</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>navigationDestination</span><span class=p>(</span><span class=k>for</span><span class=p>:</span> <span class=n>ScreenB</span><span class=p>.</span><span class=kc>self</span><span class=p>)</span> <span class=p>{</span> <span class=kc>_</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>                <span class=n>ScreenBView</span><span class=p>(</span><span class=n>onClose</span><span class=p>:</span> <span class=p>{</span> <span class=n>path</span><span class=p>.</span><span class=bp>removeLast</span><span class=p>()</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Use value types that conform to <code>Hashable</code> for path elements; keep them small (IDs, not full models).</li></ul><h2 id=navigationlink-static-destinations>NavigationLink (static destinations)<a hidden class=anchor aria-hidden=true href=#navigationlink-static-destinations>#</a></h2><ul><li>For simple lists of known destinations, <code>NavigationLink(destination:)</code> is fine. Avoid mixing old <code>NavigationView</code> with new stack APIs in the same flow.</li></ul><h2 id=deep-links>Deep Links<a hidden class=anchor aria-hidden=true href=#deep-links>#</a></h2><ul><li>Translate URLs/intents into path elements. Initialize <code>@State var path</code> from the parsed deep link so navigation reflects the initial route.</li><li>Handle unknown routes gracefully by clearing or showing a fallback screen.</li></ul><h2 id=programmatic-pops>Programmatic Pops<a hidden class=anchor aria-hidden=true href=#programmatic-pops>#</a></h2><ul><li><code>path.removeLast()</code> pops one; <code>path.removeLast(path.count)</code> pops to root. Guard against empty paths to avoid runtime errors.</li></ul><h2 id=split-view-ipad--macos-ios-16>Split View (iPad / macOS) (iOS 16+)<a hidden class=anchor aria-hidden=true href=#split-view-ipad--macos-ios-16>#</a></h2><ul><li>Use <code>NavigationSplitView</code> for master-detail; keep selection in <code>@State</code> or <code>@Binding</code> and use <code>navigationDestination</code> for detail stacks.</li></ul><h2 id=state-management-tips>State Management Tips<a hidden class=anchor aria-hidden=true href=#state-management-tips>#</a></h2><ul><li>Keep navigation state separate from data state. Use small enums/IDs to represent routes; store data elsewhere (view models, environment).</li><li>Avoid storing full models in <code>NavigationPath</code>; use identifiers and fetch as needed to reduce serialization costs and data duplication.</li></ul><h2 id=testing-and-previews>Testing and Previews<a hidden class=anchor aria-hidden=true href=#testing-and-previews>#</a></h2><ul><li>For previews, seed <code>path</code> with sample routes to verify deep links.</li><li>For UI tests, assert navigation by checking existence of destination views and path counts if exposed through accessibility.</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://sametkoyuncu.github.io/swift-notes/notes/items/swift-concurrency/><span class=title>« Prev</span><br><span></span>
</a><a class=next href=https://sametkoyuncu.github.io/swift-notes/notes/items/swiftui-state/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sametkoyuncu.github.io/swift-notes/>Swift Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>