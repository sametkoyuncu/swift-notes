<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Swift Notes</title>
<meta name=keywords content><meta name=description content="Generics and Constraints (with version cues)
Practical patterns for generics, protocol constraints, and existential usage.
Version Quick Reference

Swift 5.6+: any keyword required to spell existential types explicitly.
Swift 5.7 (Xcode 14): primary associated types, improved existential type inference, better Sendable checks behind flags.
Swift 5.9 (Xcode 15): parameter packs and variadic generics (advanced; skip unless you need them).
Swift 6+: strict concurrency checking is the default; existential/Sendable diagnostics are stricter.

where Clauses and Conditional Conformance

Use where to keep function signatures clear and constraints localized.
Conditional conformance lets you add protocol adoption only when generic parameters meet requirements.



1
2
3
4
5
6


extension Array: Encodable where Element: Encodable {}

func merge<P: Sequence, Q: Sequence>(_ lhs: P, _ rhs: Q) -> [P.Element]
where P.Element == Q.Element {
    lhs + rhs
}


Primary Associated Types (Swift 5.7)

Protocols can surface key associated types in angle brackets, reducing boilerplate when constraining existentials.



1
2
3
4
5
6
7
8


protocol IteratorProtocol<Element> {
    associatedtype Element
    mutating func next() -> Element?
}

// Prior to 5.7: `any IteratorProtocol` lost the element type easily.
// With a primary associated type you can write:
let ints: any IteratorProtocol<Int>


Existentials vs Opaque Types

any creates a type-erased box; some preserves a single concrete type.
Prefer some for return types when the function always yields one concrete conformer; use any when multiple conformers must flow through the same API or be stored together.



1
2


func makeNumber() -> some Numeric { 42 }     // static dispatch, concrete type hidden
let numbers: [any Numeric] = [1, 2.0, 3.0]   // heterogeneous storage


Protocols with Self or Associated Types

Protocols referencing Self or an associated type in requirements cannot be used as plain existentials without extra information.
Reach for:

Generics on functions or types: func render<P: View>(_ view: P) -> some View
Type erasure wrappers: struct AnyProvider<Item>: Provider { ... }
Opaque returns when a single concrete type is guaranteed.



Constraint Hygiene Tips

Keep constraints close to the API that needs them; avoid lifting all constraints to top-level types.
Prefer extension-based conformances to keep core types small and reusable.
If a type has many conditional conformances, document the minimal required constraints to avoid surprises for callers.

Testing

Add focused tests around type-erased wrappers to ensure requirements are forwarded.
For APIs relying on constraints, add compile-time checks via unused functions in test targets (e.g., a generic helper that must type-check).
"><meta name=author content><link rel=canonical href=https://sametkoyuncu.github.io/swift-notes/notes/items/generics-and-constraints/><link crossorigin=anonymous href=../../../swift-notes/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://sametkoyuncu.github.io/swift-notes/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sametkoyuncu.github.io/swift-notes/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sametkoyuncu.github.io/swift-notes/favicon-32x32.png><link rel=apple-touch-icon href=https://sametkoyuncu.github.io/swift-notes/apple-touch-icon.png><link rel=mask-icon href=https://sametkoyuncu.github.io/swift-notes/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sametkoyuncu.github.io/swift-notes/notes/items/generics-and-constraints/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://sametkoyuncu.github.io/swift-notes/notes/items/generics-and-constraints/"><meta property="og:site_name" content="Swift Notes"><meta property="og:title" content="Swift Notes"><meta property="og:description" content="Generics and Constraints (with version cues) Practical patterns for generics, protocol constraints, and existential usage.
Version Quick Reference Swift 5.6+: any keyword required to spell existential types explicitly. Swift 5.7 (Xcode 14): primary associated types, improved existential type inference, better Sendable checks behind flags. Swift 5.9 (Xcode 15): parameter packs and variadic generics (advanced; skip unless you need them). Swift 6+: strict concurrency checking is the default; existential/Sendable diagnostics are stricter. where Clauses and Conditional Conformance Use where to keep function signatures clear and constraints localized. Conditional conformance lets you add protocol adoption only when generic parameters meet requirements. 1 2 3 4 5 6 extension Array: Encodable where Element: Encodable {} func merge<P: Sequence, Q: Sequence>(_ lhs: P, _ rhs: Q) -> [P.Element] where P.Element == Q.Element { lhs + rhs } Primary Associated Types (Swift 5.7) Protocols can surface key associated types in angle brackets, reducing boilerplate when constraining existentials. 1 2 3 4 5 6 7 8 protocol IteratorProtocol<Element> { associatedtype Element mutating func next() -> Element? } // Prior to 5.7: `any IteratorProtocol` lost the element type easily. // With a primary associated type you can write: let ints: any IteratorProtocol<Int> Existentials vs Opaque Types any creates a type-erased box; some preserves a single concrete type. Prefer some for return types when the function always yields one concrete conformer; use any when multiple conformers must flow through the same API or be stored together. 1 2 func makeNumber() -> some Numeric { 42 } // static dispatch, concrete type hidden let numbers: [any Numeric] = [1, 2.0, 3.0] // heterogeneous storage Protocols with Self or Associated Types Protocols referencing Self or an associated type in requirements cannot be used as plain existentials without extra information. Reach for: Generics on functions or types: func render<P: View>(_ view: P) -> some View Type erasure wrappers: struct AnyProvider<Item>: Provider { ... } Opaque returns when a single concrete type is guaranteed. Constraint Hygiene Tips Keep constraints close to the API that needs them; avoid lifting all constraints to top-level types. Prefer extension-based conformances to keep core types small and reusable. If a type has many conditional conformances, document the minimal required constraints to avoid surprises for callers. Testing Add focused tests around type-erased wrappers to ensure requirements are forwarded. For APIs relying on constraints, add compile-time checks via unused functions in test targets (e.g., a generic helper that must type-check). "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Generics and Constraints (with version cues)
Practical patterns for generics, protocol constraints, and existential usage.
Version Quick Reference

Swift 5.6+: any keyword required to spell existential types explicitly.
Swift 5.7 (Xcode 14): primary associated types, improved existential type inference, better Sendable checks behind flags.
Swift 5.9 (Xcode 15): parameter packs and variadic generics (advanced; skip unless you need them).
Swift 6+: strict concurrency checking is the default; existential/Sendable diagnostics are stricter.

where Clauses and Conditional Conformance

Use where to keep function signatures clear and constraints localized.
Conditional conformance lets you add protocol adoption only when generic parameters meet requirements.



1
2
3
4
5
6


extension Array: Encodable where Element: Encodable {}

func merge<P: Sequence, Q: Sequence>(_ lhs: P, _ rhs: Q) -> [P.Element]
where P.Element == Q.Element {
    lhs + rhs
}


Primary Associated Types (Swift 5.7)

Protocols can surface key associated types in angle brackets, reducing boilerplate when constraining existentials.



1
2
3
4
5
6
7
8


protocol IteratorProtocol<Element> {
    associatedtype Element
    mutating func next() -> Element?
}

// Prior to 5.7: `any IteratorProtocol` lost the element type easily.
// With a primary associated type you can write:
let ints: any IteratorProtocol<Int>


Existentials vs Opaque Types

any creates a type-erased box; some preserves a single concrete type.
Prefer some for return types when the function always yields one concrete conformer; use any when multiple conformers must flow through the same API or be stored together.



1
2


func makeNumber() -> some Numeric { 42 }     // static dispatch, concrete type hidden
let numbers: [any Numeric] = [1, 2.0, 3.0]   // heterogeneous storage


Protocols with Self or Associated Types

Protocols referencing Self or an associated type in requirements cannot be used as plain existentials without extra information.
Reach for:

Generics on functions or types: func render<P: View>(_ view: P) -> some View
Type erasure wrappers: struct AnyProvider<Item>: Provider { ... }
Opaque returns when a single concrete type is guaranteed.



Constraint Hygiene Tips

Keep constraints close to the API that needs them; avoid lifting all constraints to top-level types.
Prefer extension-based conformances to keep core types small and reusable.
If a type has many conditional conformances, document the minimal required constraints to avoid surprises for callers.

Testing

Add focused tests around type-erased wrappers to ensure requirements are forwarded.
For APIs relying on constraints, add compile-time checks via unused functions in test targets (e.g., a generic helper that must type-check).
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://sametkoyuncu.github.io/swift-notes/notes/"},{"@type":"ListItem","position":2,"name":"","item":"https://sametkoyuncu.github.io/swift-notes/notes/items/generics-and-constraints/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Generics and Constraints (with version cues) Practical patterns for generics, protocol constraints, and existential usage.\nVersion Quick Reference Swift 5.6+: any keyword required to spell existential types explicitly. Swift 5.7 (Xcode 14): primary associated types, improved existential type inference, better Sendable checks behind flags. Swift 5.9 (Xcode 15): parameter packs and variadic generics (advanced; skip unless you need them). Swift 6+: strict concurrency checking is the default; existential/Sendable diagnostics are stricter. where Clauses and Conditional Conformance Use where to keep function signatures clear and constraints localized. Conditional conformance lets you add protocol adoption only when generic parameters meet requirements. 1 2 3 4 5 6 extension Array: Encodable where Element: Encodable {} func merge\u0026lt;P: Sequence, Q: Sequence\u0026gt;(_ lhs: P, _ rhs: Q) -\u0026gt; [P.Element] where P.Element == Q.Element { lhs + rhs } Primary Associated Types (Swift 5.7) Protocols can surface key associated types in angle brackets, reducing boilerplate when constraining existentials. 1 2 3 4 5 6 7 8 protocol IteratorProtocol\u0026lt;Element\u0026gt; { associatedtype Element mutating func next() -\u0026gt; Element? } // Prior to 5.7: `any IteratorProtocol` lost the element type easily. // With a primary associated type you can write: let ints: any IteratorProtocol\u0026lt;Int\u0026gt; Existentials vs Opaque Types any creates a type-erased box; some preserves a single concrete type. Prefer some for return types when the function always yields one concrete conformer; use any when multiple conformers must flow through the same API or be stored together. 1 2 func makeNumber() -\u0026gt; some Numeric { 42 } // static dispatch, concrete type hidden let numbers: [any Numeric] = [1, 2.0, 3.0] // heterogeneous storage Protocols with Self or Associated Types Protocols referencing Self or an associated type in requirements cannot be used as plain existentials without extra information. Reach for: Generics on functions or types: func render\u0026lt;P: View\u0026gt;(_ view: P) -\u0026gt; some View Type erasure wrappers: struct AnyProvider\u0026lt;Item\u0026gt;: Provider { ... } Opaque returns when a single concrete type is guaranteed. Constraint Hygiene Tips Keep constraints close to the API that needs them; avoid lifting all constraints to top-level types. Prefer extension-based conformances to keep core types small and reusable. If a type has many conditional conformances, document the minimal required constraints to avoid surprises for callers. Testing Add focused tests around type-erased wrappers to ensure requirements are forwarded. For APIs relying on constraints, add compile-time checks via unused functions in test targets (e.g., a generic helper that must type-check). ","keywords":[],"articleBody":"Generics and Constraints (with version cues) Practical patterns for generics, protocol constraints, and existential usage.\nVersion Quick Reference Swift 5.6+: any keyword required to spell existential types explicitly. Swift 5.7 (Xcode 14): primary associated types, improved existential type inference, better Sendable checks behind flags. Swift 5.9 (Xcode 15): parameter packs and variadic generics (advanced; skip unless you need them). Swift 6+: strict concurrency checking is the default; existential/Sendable diagnostics are stricter. where Clauses and Conditional Conformance Use where to keep function signatures clear and constraints localized. Conditional conformance lets you add protocol adoption only when generic parameters meet requirements. 1 2 3 4 5 6 extension Array: Encodable where Element: Encodable {} func merge\u003cP: Sequence, Q: Sequence\u003e(_ lhs: P, _ rhs: Q) -\u003e [P.Element] where P.Element == Q.Element { lhs + rhs } Primary Associated Types (Swift 5.7) Protocols can surface key associated types in angle brackets, reducing boilerplate when constraining existentials. 1 2 3 4 5 6 7 8 protocol IteratorProtocol\u003cElement\u003e { associatedtype Element mutating func next() -\u003e Element? } // Prior to 5.7: `any IteratorProtocol` lost the element type easily. // With a primary associated type you can write: let ints: any IteratorProtocol\u003cInt\u003e Existentials vs Opaque Types any creates a type-erased box; some preserves a single concrete type. Prefer some for return types when the function always yields one concrete conformer; use any when multiple conformers must flow through the same API or be stored together. 1 2 func makeNumber() -\u003e some Numeric { 42 } // static dispatch, concrete type hidden let numbers: [any Numeric] = [1, 2.0, 3.0] // heterogeneous storage Protocols with Self or Associated Types Protocols referencing Self or an associated type in requirements cannot be used as plain existentials without extra information. Reach for: Generics on functions or types: func render(_ view: P) -\u003e some View Type erasure wrappers: struct AnyProvider: Provider { ... } Opaque returns when a single concrete type is guaranteed. Constraint Hygiene Tips Keep constraints close to the API that needs them; avoid lifting all constraints to top-level types. Prefer extension-based conformances to keep core types small and reusable. If a type has many conditional conformances, document the minimal required constraints to avoid surprises for callers. Testing Add focused tests around type-erased wrappers to ensure requirements are forwarded. For APIs relying on constraints, add compile-time checks via unused functions in test targets (e.g., a generic helper that must type-check). ","wordCount":"401","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sametkoyuncu.github.io/swift-notes/notes/items/generics-and-constraints/"},"publisher":{"@type":"Organization","name":"Swift Notes","logo":{"@type":"ImageObject","url":"https://sametkoyuncu.github.io/swift-notes/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://sametkoyuncu.github.io/swift-notes/ accesskey=h title="Swift Notes (Alt + H)">Swift Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sametkoyuncu.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://sametkoyuncu.github.io/cheat-sheets/ title="Cheat Sheets"><span>Cheat Sheets</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sametkoyuncu.github.io/swift-notes/>Home</a>&nbsp;»&nbsp;<a href=https://sametkoyuncu.github.io/swift-notes/notes/>Notes</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta><span>2 min</span></div></header><div class=post-content><h1 id=generics-and-constraints-with-version-cues>Generics and Constraints (with version cues)<a hidden class=anchor aria-hidden=true href=#generics-and-constraints-with-version-cues>#</a></h1><p>Practical patterns for generics, protocol constraints, and existential usage.</p><h2 id=version-quick-reference>Version Quick Reference<a hidden class=anchor aria-hidden=true href=#version-quick-reference>#</a></h2><ul><li>Swift 5.6+: <code>any</code> keyword required to spell existential types explicitly.</li><li>Swift 5.7 (Xcode 14): primary associated types, improved existential type inference, better <code>Sendable</code> checks behind flags.</li><li>Swift 5.9 (Xcode 15): parameter packs and variadic generics (advanced; skip unless you need them).</li><li>Swift 6+: strict concurrency checking is the default; existential/<code>Sendable</code> diagnostics are stricter.</li></ul><h2 id=where-clauses-and-conditional-conformance><code>where</code> Clauses and Conditional Conformance<a hidden class=anchor aria-hidden=true href=#where-clauses-and-conditional-conformance>#</a></h2><ul><li>Use <code>where</code> to keep function signatures clear and constraints localized.</li><li>Conditional conformance lets you add protocol adoption only when generic parameters meet requirements.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>extension</span> <span class=nc>Array</span><span class=p>:</span> <span class=n>Encodable</span> <span class=k>where</span> <span class=n>Element</span><span class=p>:</span> <span class=n>Encodable</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>merge</span><span class=p>&lt;</span><span class=n>P</span><span class=p>:</span> <span class=n>Sequence</span><span class=p>,</span> <span class=n>Q</span><span class=p>:</span> <span class=n>Sequence</span><span class=p>&gt;(</span><span class=kc>_</span> <span class=n>lhs</span><span class=p>:</span> <span class=n>P</span><span class=p>,</span> <span class=kc>_</span> <span class=n>rhs</span><span class=p>:</span> <span class=n>Q</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>[</span><span class=n>P</span><span class=p>.</span><span class=n>Element</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>where</span> <span class=n>P</span><span class=p>.</span><span class=n>Element</span> <span class=p>==</span> <span class=n>Q</span><span class=p>.</span><span class=n>Element</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>lhs</span> <span class=o>+</span> <span class=n>rhs</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=primary-associated-types-swift-57>Primary Associated Types (Swift 5.7)<a hidden class=anchor aria-hidden=true href=#primary-associated-types-swift-57>#</a></h2><ul><li>Protocols can surface key associated types in angle brackets, reducing boilerplate when constraining existentials.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>protocol</span> <span class=nc>IteratorProtocol</span><span class=p>&lt;</span><span class=n>Element</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>associatedtype</span> <span class=n>Element</span>
</span></span><span class=line><span class=cl>    <span class=kr>mutating</span> <span class=kd>func</span> <span class=nf>next</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=n>Element</span><span class=p>?</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Prior to 5.7: `any IteratorProtocol` lost the element type easily.</span>
</span></span><span class=line><span class=cl><span class=c1>// With a primary associated type you can write:</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>ints</span><span class=p>:</span> <span class=n>any</span> <span class=n>IteratorProtocol</span><span class=p>&lt;</span><span class=nb>Int</span><span class=p>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=existentials-vs-opaque-types>Existentials vs Opaque Types<a hidden class=anchor aria-hidden=true href=#existentials-vs-opaque-types>#</a></h2><ul><li><code>any</code> creates a type-erased box; <code>some</code> preserves a single concrete type.</li><li>Prefer <code>some</code> for return types when the function always yields one concrete conformer; use <code>any</code> when multiple conformers must flow through the same API or be stored together.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>makeNumber</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=n>some</span> <span class=n>Numeric</span> <span class=p>{</span> <span class=mi>42</span> <span class=p>}</span>     <span class=c1>// static dispatch, concrete type hidden</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>numbers</span><span class=p>:</span> <span class=p>[</span><span class=n>any</span> <span class=n>Numeric</span><span class=p>]</span> <span class=p>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mf>2.0</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>]</span>   <span class=c1>// heterogeneous storage</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=protocols-with-self-or-associated-types>Protocols with <code>Self</code> or Associated Types<a hidden class=anchor aria-hidden=true href=#protocols-with-self-or-associated-types>#</a></h2><ul><li>Protocols referencing <code>Self</code> or an associated type in requirements cannot be used as plain existentials without extra information.</li><li>Reach for:<ul><li>Generics on functions or types: <code>func render&lt;P: View>(_ view: P) -> some View</code></li><li>Type erasure wrappers: <code>struct AnyProvider&lt;Item>: Provider { ... }</code></li><li>Opaque returns when a single concrete type is guaranteed.</li></ul></li></ul><h2 id=constraint-hygiene-tips>Constraint Hygiene Tips<a hidden class=anchor aria-hidden=true href=#constraint-hygiene-tips>#</a></h2><ul><li>Keep constraints close to the API that needs them; avoid lifting all constraints to top-level types.</li><li>Prefer extension-based conformances to keep core types small and reusable.</li><li>If a type has many conditional conformances, document the minimal required constraints to avoid surprises for callers.</li></ul><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><ul><li>Add focused tests around type-erased wrappers to ensure requirements are forwarded.</li><li>For APIs relying on constraints, add compile-time checks via unused functions in test targets (e.g., a generic helper that must type-check).</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://sametkoyuncu.github.io/swift-notes/notes/items/error-handling/><span class=title>« Prev</span><br><span></span>
</a><a class=next href=https://sametkoyuncu.github.io/swift-notes/notes/items/keypaths-and-pattern-matching/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sametkoyuncu.github.io/swift-notes/>Swift Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>